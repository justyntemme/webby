<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webby - EPUB Library</title>
    <!-- Modular CSS -->
    <link rel="stylesheet" href="/static/css/base.css">
    <link rel="stylesheet" href="/static/css/layout.css">
    <link rel="stylesheet" href="/static/css/components.css">
    <link rel="stylesheet" href="/static/css/modals.css">
    <style>
        /* Page-specific styles that don't fit in modules */

        /* Series detail page styles */
        .series-detail-section {
            padding: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .series-header {
            display: flex;
            gap: 24px;
            margin-bottom: 32px;
        }

        .series-cover {
            width: 200px;
            flex-shrink: 0;
        }

        .series-cover img {
            width: 100%;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
        }

        .series-info h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .series-meta {
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .series-description {
            line-height: 1.6;
            color: var(--text-color);
        }

        .series-books-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .series-books-grid .book-card {
            background: var(--card-bg);
        }

        /* Expanded series view */
        .series-expanded {
            grid-column: 1 / -1;
            background: var(--bg-secondary);
            border-radius: var(--radius);
            padding: 15px;
            margin: 10px 0;
        }

        .series-expanded-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .series-expanded-title {
            font-size: 18px;
            font-weight: bold;
        }

        .series-collapse-btn {
            background: none;
            border: 1px solid var(--border-color);
            padding: 5px 15px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            color: var(--text-color);
        }

        .series-collapse-btn:hover {
            background: var(--hover-bg);
        }
    </style>
</head>
<body>

    <!-- Mobile-First Header -->
    <header class="header" id="mainHeader">
        <div class="header-left">
            <button class="menu-btn" id="menuBtn" aria-label="Open menu">&#9776;</button>
            <h1>Webby</h1>
        </div>
        <div class="header-right">
            <button class="header-icon-btn mobile-only" id="searchToggleBtn" aria-label="Search">&#128269;</button>
            <div class="user-section" id="userSection"></div>
        </div>
        <!-- Mobile Search (expandable) -->
        <div class="mobile-search-container" id="mobileSearchContainer">
            <input type="text" id="mobileSearchInput" placeholder="Search books...">
            <button class="header-icon-btn" id="closeSearchBtn">&times;</button>
        </div>
        <!-- Desktop Controls -->
        <div class="controls">
            <input type="text" class="search-box" id="searchBox" placeholder="Search books...">
            <select class="type-select" id="typeSelect">
                <option value="">All Items</option>
                <option value="book">Books Only</option>
                <option value="comic">Comics Only</option>
            </select>
            <select class="type-select" id="statusSelect">
                <option value="">All Status</option>
                <option value="unread">Unread</option>
                <option value="reading">Reading</option>
                <option value="completed">Completed</option>
            </select>
            <select class="type-select" id="tagSelect">
                <option value="">All Tags</option>
            </select>
            <select class="sort-select" id="sortSelect">
                <option value="title">Sort by Title</option>
                <option value="author">Sort by Author</option>
                <option value="series">Sort by Series</option>
                <option value="date">Sort by Date Added</option>
            </select>
            <div class="view-toggle">
                <button id="gridViewBtn" class="active">Grid</button>
                <button id="listViewBtn">List</button>
            </div>
            <div class="view-toggle">
                <button id="groupOffBtn" class="active">All</button>
                <button id="groupSeriesBtn">Group Series</button>
            </div>
            <button class="upload-btn" id="statsBtn" style="background: var(--info-color, #17a2b8);">Stats</button>
            <button class="upload-btn" id="collectionsBtn" style="background: var(--secondary-color, #6c757d);">Collections</button>
            <button class="upload-btn" id="uploadBtn">+ Upload</button>
        </div>
    </header>

    <!-- Filter Drawer (Mobile) -->
    <div class="filter-drawer-overlay" id="filterOverlay"></div>
    <div class="filter-drawer" id="filterDrawer">
        <div class="filter-drawer-header">
            <h2>Filters & Options</h2>
            <button class="filter-drawer-close" id="closeDrawerBtn">&times;</button>
        </div>
        <div class="filter-drawer-content">
            <div class="filter-group">
                <label>Search</label>
                <input type="text" id="drawerSearchInput" placeholder="Search books...">
            </div>
            <div class="filter-group">
                <label>Content Type</label>
                <select id="drawerTypeSelect">
                    <option value="">All Items</option>
                    <option value="book">Books Only</option>
                    <option value="comic">Comics Only</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Status</label>
                <select id="drawerStatusSelect">
                    <option value="">All Status</option>
                    <option value="unread">Unread</option>
                    <option value="reading">Reading</option>
                    <option value="completed">Completed</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Tags</label>
                <select id="drawerTagSelect">
                    <option value="">All Tags</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Sort By</label>
                <select id="drawerSortSelect">
                    <option value="title">Title</option>
                    <option value="author">Author</option>
                    <option value="series">Series</option>
                    <option value="date">Date Added</option>
                </select>
            </div>
            <div class="filter-group">
                <label>View</label>
                <div class="filter-toggle-group">
                    <button id="drawerGridBtn" class="active">Grid</button>
                    <button id="drawerListBtn">List</button>
                </div>
            </div>
            <div class="filter-group">
                <label>Grouping</label>
                <div class="filter-toggle-group">
                    <button id="drawerGroupOffBtn" class="active">All</button>
                    <button id="drawerGroupSeriesBtn">By Series</button>
                </div>
            </div>
        </div>
        <div class="filter-drawer-footer">
            <div class="user-info-mobile" id="drawerUserInfo">
                <!-- Populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Bottom Navigation (Mobile) -->
    <nav class="bottom-nav" id="bottomNav">
        <button class="bottom-nav-item active" id="navLibrary">
            <span class="icon">&#128218;</span>
            <span class="label">Library</span>
        </button>
        <button class="bottom-nav-item" id="navCollections">
            <span class="icon">&#128194;</span>
            <span class="label">Collections</span>
        </button>
        <button class="bottom-nav-item" id="navStats">
            <span class="icon">&#128200;</span>
            <span class="label">Stats</span>
        </button>
        <button class="bottom-nav-item" id="navMore">
            <span class="icon">&#8943;</span>
            <span class="label">More</span>
        </button>
    </nav>

    <!-- Floating Action Button (Upload) -->
    <button class="fab" id="fabUpload" aria-label="Upload books">+</button>

    <main class="library" id="library">
        <div class="loading">Loading library...</div>
    </main>

    <!-- Book Detail Modal -->
    <div class="modal book-detail-modal" id="bookDetailModal">
        <div class="modal-content">
            <div class="book-detail-header">
                <div class="book-detail-cover" id="detailCover"></div>
                <div class="book-detail-main">
                    <h2 id="detailTitle"></h2>
                    <div class="book-detail-author" id="detailAuthor"></div>
                    <div class="book-detail-series" id="detailSeries"></div>
                    <div class="book-detail-status" style="margin-bottom: 12px;">
                        <label style="font-size: 13px; color: var(--text-secondary); margin-right: 8px;">Status:</label>
                        <select id="detailStatusSelect" class="type-select" style="min-width: 140px; padding: 8px 12px;">
                            <option value="unread">Unread</option>
                            <option value="reading">Reading</option>
                            <option value="completed">Completed</option>
                        </select>
                    </div>
                    <div class="star-rating-section">
                        <label>Rating:</label>
                        <div class="star-rating" id="detailStarRating">
                            <span class="star" data-value="1">‚òÖ</span>
                            <span class="star" data-value="2">‚òÖ</span>
                            <span class="star" data-value="3">‚òÖ</span>
                            <span class="star" data-value="4">‚òÖ</span>
                            <span class="star" data-value="5">‚òÖ</span>
                        </div>
                    </div>
                    <div class="reading-lists-section" id="readingListsSection">
                        <button class="reading-list-btn want-to-read" id="wantToReadBtn" onclick="toggleReadingList('want_to_read')">
                            <span class="icon">üìö</span>
                            <span>Want to Read</span>
                        </button>
                        <button class="reading-list-btn favorites" id="favoritesBtn" onclick="toggleReadingList('favorites')">
                            <span class="icon">‚ù§Ô∏è</span>
                            <span>Favorites</span>
                        </button>
                    </div>
                    <div class="tags-section" id="tagsSection">
                        <label>Tags:</label>
                        <div class="tags-container" id="bookTagsContainer">
                            <span class="no-tags-message" id="noTagsMsg">No tags</span>
                            <div class="tag-dropdown">
                                <button class="add-tag-btn" onclick="toggleTagDropdown(event)">+ Add tag</button>
                                <div class="tag-dropdown-content" id="tagDropdown">
                                    <div class="tag-input-container">
                                        <input type="text" id="tagSearchInput" placeholder="Search or create tag..." oninput="filterTags(this.value)">
                                    </div>
                                    <div id="tagDropdownList"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="book-detail-actions">
                        <button class="primary-btn" id="readBookBtn">Read Book</button>
                        <button id="editMetadataBtn">‚úé Edit</button>
                        <button id="searchMetadataBtn">üîç Search</button>
                        <button id="refreshMetadataBtn">‚Üª Refresh</button>
                        <button id="closeDetailBtn">Close</button>
                    </div>
                </div>
            </div>
            <div id="refreshResult"></div>
            <div class="metadata-section">
                <h3>
                    Book Details
                    <span class="metadata-source-badge" id="metadataSource"></span>
                </h3>
                <div class="metadata-grid" id="metadataGrid"></div>
                <div class="metadata-updated" id="metadataUpdated"></div>
            </div>
            <div class="annotations-section" id="annotationsSection" style="display: none;">
                <h3>Annotations & Highlights <span id="annotationCount" style="font-size: 14px; font-weight: normal; color: var(--text-secondary);"></span></h3>
                <div id="annotationsSummary" style="margin-top: 10px;"></div>
            </div>
            <div class="similar-books-section" id="similarBooksSection" style="display: none;">
                <h3>Similar Books <span id="similarBooksCount" style="font-size: 14px; font-weight: normal; color: var(--text-secondary);"></span></h3>
                <div class="similar-books-grid" id="similarBooksGrid"></div>
            </div>
        </div>
    </div>

    <!-- Edit Metadata Modal -->
    <div class="modal edit-modal" id="editMetadataModal">
        <div class="modal-content">
            <h2>Edit Book Metadata</h2>
            <form id="editMetadataForm">
                <div class="form-group">
                    <label for="editTitle">Title</label>
                    <input type="text" id="editTitle" name="title" placeholder="Optional">
                </div>
                <div class="form-group">
                    <label for="editAuthor">Author</label>
                    <input type="text" id="editAuthor" name="author" placeholder="Optional">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="editSeries">Series</label>
                        <input type="text" id="editSeries" name="series" placeholder="Optional">
                    </div>
                    <div class="form-group">
                        <label for="editSeriesIndex">Series #</label>
                        <input type="number" id="editSeriesIndex" name="series_index" step="0.1" min="0" placeholder="1">
                    </div>
                </div>
                <div class="form-group">
                    <label for="editISBN">ISBN</label>
                    <input type="text" id="editISBN" name="isbn" placeholder="10 or 13 digits">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="editPublisher">Publisher</label>
                        <input type="text" id="editPublisher" name="publisher">
                    </div>
                    <div class="form-group">
                        <label for="editPublishDate">Publish Date</label>
                        <input type="text" id="editPublishDate" name="publish_date" placeholder="e.g., 2023">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="editLanguage">Language</label>
                        <input type="text" id="editLanguage" name="language" placeholder="e.g., en">
                    </div>
                    <div class="form-group">
                        <label for="editSubjects">Subjects</label>
                        <input type="text" id="editSubjects" name="subjects" placeholder="Comma-separated">
                    </div>
                </div>
                <div class="form-group">
                    <label for="editDescription">Description</label>
                    <textarea id="editDescription" name="description" placeholder="Book description..."></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" id="searchFromEditBtn" class="search-btn" title="Search for metadata online">Search Metadata</button>
                    <button type="button" id="cancelEditBtn">Cancel</button>
                    <button type="submit" class="save-btn" id="saveEditBtn">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Search Metadata Modal -->
    <div class="modal search-modal" id="searchMetadataModal">
        <div class="modal-content">
            <h2>Search for Metadata</h2>
            <div class="search-form-section">
                <div class="form-group">
                    <label for="searchTitle">Title</label>
                    <input type="text" id="searchTitle" placeholder="Book title">
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="searchAuthor">Author</label>
                        <input type="text" id="searchAuthor" placeholder="Author name">
                    </div>
                    <div class="form-group">
                        <label for="searchISBN">ISBN</label>
                        <input type="text" id="searchISBN" placeholder="ISBN-10 or ISBN-13">
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="searchYear">Publication Year</label>
                        <input type="text" id="searchYear" placeholder="e.g., 2023">
                    </div>
                    <div class="form-group">
                        <label for="searchSeriesNum">Series/Issue #</label>
                        <input type="text" id="searchSeriesNum" placeholder="e.g., 1, 2, 3">
                    </div>
                </div>
                <div class="search-actions">
                    <button type="button" id="doSearchBtn" class="primary-btn">Search</button>
                    <button type="button" id="cancelSearchBtn">Cancel</button>
                </div>
            </div>
            <div id="searchResults" class="search-results" style="display: none;">
                <h3>Search Results</h3>
                <div id="resultsContainer"></div>
            </div>
            <div id="selectedPreview" class="selected-preview" style="display: none;">
                <h3>Selected Metadata</h3>
                <div id="previewContent"></div>
                <div class="preview-actions">
                    <button type="button" id="applyMetadataBtn" class="primary-btn">Apply to Book</button>
                    <button type="button" id="backToResultsBtn">Back to Results</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Collections Modal -->
    <div class="modal" id="collectionsModal">
        <div class="modal-content" style="max-width: 800px;">
            <h2>Collections</h2>
            <div style="display: flex; gap: 20px;">
                <!-- Collections List -->
                <div style="flex: 1; max-height: 400px; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Your Collections</h3>
                        <button id="newCollectionBtn" class="primary-btn">+ New Collection</button>
                    </div>
                    <div id="collectionsList" style="display: flex; flex-direction: column; gap: 10px;">
                        <div class="loading">Loading collections...</div>
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; text-align: right;">
                <button id="closeCollectionsBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- New Collection Modal -->
    <div class="modal" id="newCollectionModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>Create Collection</h2>
            <form id="newCollectionForm">
                <div class="form-group">
                    <label for="collectionName">Collection Name</label>
                    <input type="text" id="collectionName" name="name" required placeholder="My Collection">
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="isSmartCollection"> Make this a Smart Collection
                    </label>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-top: 5px;">
                        Smart collections automatically populate based on rules you define.
                    </p>
                </div>
                <div id="smartCollectionRules" style="display: none;">
                    <div class="form-group">
                        <label>Rule Logic</label>
                        <select id="ruleLogic">
                            <option value="AND">Match ALL rules (AND)</option>
                            <option value="OR">Match ANY rule (OR)</option>
                        </select>
                    </div>
                    <div id="rulesList">
                        <div class="rule-row" style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <select class="rule-field" style="flex: 1;">
                                <option value="author">Author</option>
                                <option value="title">Title</option>
                                <option value="series">Series</option>
                                <option value="format">Format</option>
                                <option value="content_type">Type (Book/Comic)</option>
                                <option value="year">Year</option>
                                <option value="rating">Rating</option>
                                <option value="read_status">Read Status</option>
                                <option value="tags">Tag</option>
                            </select>
                            <select class="rule-operator" style="flex: 1;">
                                <option value="contains">Contains</option>
                                <option value="equals">Equals</option>
                                <option value="starts_with">Starts With</option>
                                <option value="greater_than">Greater Than</option>
                                <option value="less_than">Less Than</option>
                            </select>
                            <input type="text" class="rule-value" style="flex: 1;" placeholder="Value">
                            <button type="button" class="remove-rule-btn" style="padding: 5px 10px;">X</button>
                        </div>
                    </div>
                    <button type="button" id="addRuleBtn" style="margin-bottom: 15px;">+ Add Rule</button>
                </div>
                <div class="form-actions">
                    <button type="button" id="cancelNewCollectionBtn">Cancel</button>
                    <button type="submit" class="save-btn">Create Collection</button>
                </div>
            </form>
        </div>
    </div>

    <!-- View Collection Modal -->
    <div class="modal" id="viewCollectionModal">
        <div class="modal-content" style="max-width: 900px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 id="viewCollectionName">Collection</h2>
                <span id="viewCollectionBadge" style="padding: 3px 10px; background: var(--accent-color); color: white; border-radius: 10px; font-size: 12px;"></span>
            </div>
            <div id="viewCollectionRules" style="margin-bottom: 15px; padding: 10px; background: var(--header-bg); border-radius: 5px; display: none;">
                <strong>Rules:</strong> <span id="viewCollectionRulesText"></span>
            </div>
            <div id="viewCollectionBooks" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; align-items: start;">
                <div class="loading">Loading books...</div>
            </div>
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="deleteCollectionBtn" style="background: var(--danger-color); color: white;">Delete Collection</button>
                <button id="closeViewCollectionBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div class="modal" id="statsModal">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <h2>Reading Statistics</h2>

            <!-- Stats Summary Cards -->
            <div id="statsSummary" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 25px;">
                <div class="stat-card" style="background: var(--header-bg); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 28px; font-weight: bold; color: var(--accent-color);" id="statBooksRead">0</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Books Completed</div>
                </div>
                <div class="stat-card" style="background: var(--header-bg); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 28px; font-weight: bold; color: var(--accent-color);" id="statPagesRead">0</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Pages Read</div>
                </div>
                <div class="stat-card" style="background: var(--header-bg); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 28px; font-weight: bold; color: var(--accent-color);" id="statTotalTime">0m</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Reading Time</div>
                </div>
                <div class="stat-card" style="background: var(--header-bg); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 28px; font-weight: bold; color: var(--warning-color);" id="statCurrentStreak">0</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Day Streak</div>
                </div>
                <div class="stat-card" style="background: var(--header-bg); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 28px; font-weight: bold; color: var(--success-color);" id="statLongestStreak">0</div>
                    <div style="font-size: 12px; color: var(--text-muted);">Best Streak</div>
                </div>
            </div>

            <!-- Daily Reading Chart -->
            <div style="margin-bottom: 25px;">
                <h3 style="margin-bottom: 15px;">Reading Activity (Last 30 Days)</h3>
                <div id="dailyChart" style="height: 200px; background: var(--header-bg); border-radius: 8px; padding: 15px; display: flex; align-items: flex-end; gap: 3px; overflow-x: auto;">
                    <div class="loading">Loading chart...</div>
                </div>
            </div>

            <!-- Recent Reading Sessions -->
            <div style="margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px;">Recent Reading Sessions</h3>
                <div id="recentSessions" style="max-height: 250px; overflow-y: auto;">
                    <div class="loading">Loading sessions...</div>
                </div>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="closeStatsBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div class="modal" id="uploadModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>Upload Books</h2>
            <div class="drop-zone" id="dropZone">
                <p>Drag & drop EPUB, PDF, CBZ, or CBR files here</p>
                <p>or click to browse (multiple files supported)</p>
                <input type="file" class="file-input" id="fileInput" accept=".epub,.pdf,.cbz,.cbr" multiple>
            </div>

            <!-- Batch Upload Progress -->
            <div id="batchUploadSection" style="display: none; margin-top: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span id="batchUploadSummary">0 of 0 files uploaded</span>
                    <label style="font-size: 12px; display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" id="autoMetadataFetch" checked>
                        Auto-fetch metadata
                    </label>
                </div>
                <div class="progress-bar" style="margin-bottom: 10px;">
                    <div class="progress-fill" id="batchProgressFill" style="width: 0%;"></div>
                </div>
                <div id="fileUploadList" style="max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 5px;">
                </div>
            </div>

            <!-- Import Summary (shown after completion) -->
            <div id="importSummary" style="display: none; margin-top: 15px; padding: 15px; background: var(--header-bg); border-radius: 8px;">
                <h3 style="margin: 0 0 10px 0;">Import Complete</h3>
                <div style="display: flex; gap: 20px; margin-bottom: 10px;">
                    <div><span style="color: var(--success-color); font-weight: bold;" id="successCount">0</span> Successful</div>
                    <div><span style="color: var(--danger-color); font-weight: bold;" id="failedCount">0</span> Failed</div>
                    <div><span style="color: var(--secondary-color); font-weight: bold;" id="skippedCount">0</span> Skipped</div>
                </div>
                <div id="failedFilesList" style="display: none; max-height: 100px; overflow-y: auto; font-size: 12px; color: var(--danger-color);"></div>
                <button id="retryFailedBtn" style="display: none; margin-top: 10px; background: var(--warning-color); color: #000;">Retry Failed</button>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="cancel-btn" id="cancelBtn">Close</button>
                <button id="clearUploadBtn" style="display: none;">Clear & Upload More</button>
            </div>
        </div>
    </div>

    <!-- Mobile Action Menu (Bottom Sheet) -->
    <div class="mobile-action-menu" id="mobileActionMenu">
        <div class="mobile-action-content">
            <div class="mobile-action-header">
                <h3 id="mobileActionTitle">Book Title</h3>
                <p id="mobileActionAuthor">by Author</p>
            </div>
            <button class="mobile-action-item" onclick="mobileActionRead()">Read</button>
            <button class="mobile-action-item" onclick="mobileActionViewDetails()">View Details</button>
            <button class="mobile-action-item" onclick="mobileActionEdit()">Edit Metadata</button>
            <button class="mobile-action-item" onclick="mobileActionRefresh()">Refresh Metadata</button>
            <button class="mobile-action-item" onclick="mobileActionSearch()">Search Metadata</button>
            <button class="mobile-action-item danger" onclick="mobileActionDelete()">Delete</button>
            <div class="mobile-action-cancel">
                <button class="mobile-action-item" onclick="closeMobileActionMenu()">
                    <span>Cancel</span>
                </button>
            </div>
        </div>
    </div>

    <!-- DOMPurify for XSS protection -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js" integrity="sha512-H+rglffZ6f5gF7UJgvH4Naa+fGCgjrHKMgoFOGmcPTRwR6oILo5R+gtzNrpDp7iMV3udbymBVjkeZGNz1Em4rQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- ES Modules -->
    <script type="module" src="/static/js/main.js"></script>

    <!-- Legacy inline script (to be migrated incrementally) -->
    <script>
        const API_BASE = '/api';
        let books = [];
        let viewMode = 'grid';
        let groupBy = null;
        let currentUser = null;
        let groupSeries = false; // Series grouping mode
        let expandedSeries = null; // Currently expanded series name

        // Mobile action menu state
        let mobileActionBookId = null;
        let mobileActionBookData = null;
        let longPressTimer = null;
        const LONG_PRESS_DURATION = 500; // ms

        // Auth helpers
        function getAuthToken() {
            return localStorage.getItem('webby-token');
        }

        function clearAuthToken() {
            localStorage.removeItem('webby-token');
        }

        function getAuthHeaders() {
            const headers = {};
            const token = getAuthToken();
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            return headers;
        }

        async function checkAuth() {
            const token = getAuthToken();
            if (!token) {
                // No token, redirect to login
                window.location.href = '/auth';
                return false;
            }

            try {
                const res = await fetch(`${API_BASE}/auth/me`, {
                    headers: getAuthHeaders()
                });
                if (res.ok) {
                    const data = await res.json();
                    currentUser = data.user;
                    renderUserSection(currentUser);
                    return true;
                } else {
                    // Token invalid, redirect to login
                    clearAuthToken();
                    window.location.href = '/auth';
                    return false;
                }
            } catch (err) {
                // Error checking auth, redirect to login
                window.location.href = '/auth';
                return false;
            }
        }

        function renderUserSection(user) {
            const section = document.getElementById('userSection');
            if (user) {
                section.innerHTML = `
                    <span class="user-info">Signed in as <strong>${user.username}</strong></span>
                    <button class="auth-btn" onclick="logout()">Sign Out</button>
                `;
            } else {
                section.innerHTML = `
                    <a href="/auth" class="auth-btn primary">Sign In</a>
                `;
            }
        }

        function logout() {
            clearAuthToken();
            currentUser = null;
            renderUserSection(null);
            loadBooks(); // Reload to show public books only
        }

        async function loadBooks() {
            const library = document.getElementById('library');
            const sortBy = document.getElementById('sortSelect').value;
            const search = document.getElementById('searchBox').value;
            const contentType = document.getElementById('typeSelect').value;
            const readStatus = document.getElementById('statusSelect').value;
            const selectedTag = document.getElementById('tagSelect').value;

            try {
                let fetchedBooks;

                // If tag is selected, fetch books by tag first then apply other filters
                if (selectedTag) {
                    const tagRes = await fetch(`${API_BASE}/tags/${selectedTag}/books`, { headers: getAuthHeaders() });
                    const tagData = await tagRes.json();
                    fetchedBooks = tagData.books || [];

                    // Apply additional filters client-side
                    if (search) {
                        const searchLower = search.toLowerCase();
                        fetchedBooks = fetchedBooks.filter(b =>
                            b.title.toLowerCase().includes(searchLower) ||
                            b.author.toLowerCase().includes(searchLower)
                        );
                    }
                    if (contentType) {
                        fetchedBooks = fetchedBooks.filter(b => b.content_type === contentType);
                    }
                    if (readStatus) {
                        fetchedBooks = fetchedBooks.filter(b => b.read_status === readStatus);
                    }
                } else {
                    let url = `${API_BASE}/books?sort=${sortBy}`;
                    if (search) url += `&search=${encodeURIComponent(search)}`;
                    if (contentType) url += `&type=${contentType}`;
                    if (readStatus) url += `&status=${readStatus}`;

                    const res = await fetch(url, { headers: getAuthHeaders() });
                    const data = await res.json();
                    fetchedBooks = data.books || [];
                }

                books = fetchedBooks;
                renderBooks();
            } catch (err) {
                library.innerHTML = '<div class="empty-state"><h2>Failed to load library</h2></div>';
            }
        }

        async function loadGrouped(type) {
            const library = document.getElementById('library');

            try {
                const res = await fetch(`${API_BASE}/books/by-${type}`, { headers: getAuthHeaders() });
                const data = await res.json();
                const groups = data[type === 'author' ? 'authors' : 'series'] || {};
                renderGrouped(groups);
            } catch (err) {
                library.innerHTML = '<div class="empty-state"><h2>Failed to load library</h2></div>';
            }
        }

        function renderBooks() {
            const library = document.getElementById('library');

            if (books.length === 0) {
                library.innerHTML = `
                    <div class="empty-state">
                        <h2>No books yet</h2>
                        <p>Upload your first EPUB to get started</p>
                    </div>
                `;
                return;
            }

            const containerClass = viewMode === 'grid' ? 'books-grid' : 'books-list';

            // Check if series grouping is enabled
            if (groupSeries) {
                const { seriesGroups, standalone } = groupBooksBySeries(books);
                let html = `<div class="${containerClass}">`;

                // Render series groups
                Object.entries(seriesGroups).forEach(([seriesName, seriesBooks]) => {
                    if (expandedSeries === seriesName) {
                        // Show expanded series view
                        html += renderExpandedSeries(seriesName, seriesBooks);
                    } else {
                        // Show collapsed series card
                        html += renderSeriesCard(seriesName, seriesBooks);
                    }
                });

                // Render standalone books (no series)
                standalone.forEach(book => {
                    html += renderBook(book);
                });

                html += '</div>';
                library.innerHTML = html;
            } else {
                library.innerHTML = `<div class="${containerClass}">${books.map(renderBook).join('')}</div>`;
            }
        }

        function renderGrouped(groups) {
            const library = document.getElementById('library');

            if (Object.keys(groups).length === 0) {
                library.innerHTML = `
                    <div class="empty-state">
                        <h2>No books found</h2>
                    </div>
                `;
                return;
            }

            const containerClass = viewMode === 'grid' ? 'books-grid' : 'books-list';
            library.innerHTML = Object.entries(groups).map(([name, groupBooks]) => `
                <h2 class="group-header">${name}</h2>
                <div class="${containerClass}">${groupBooks.map(renderBook).join('')}</div>
            `).join('');
        }

        function renderBook(book) {
            const coverUrl = `${API_BASE}/books/${book.id}/cover`;
            const escapedTitle = book.title.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const contentType = book.content_type || 'book';
            const readStatus = book.read_status || 'unread';
            const showTypeBadge = document.getElementById('typeSelect').value === ''; // Show badge only when viewing "All Items"
            const showStatusBadge = document.getElementById('statusSelect').value === ''; // Show status badge only when viewing "All Status"
            const typeBadgeHtml = showTypeBadge ? `<span class="content-type-badge ${contentType}">${contentType}</span>` : '';
            const statusBadgeHtml = showStatusBadge && readStatus !== 'unread' ? `<span class="read-status-badge ${readStatus}">${readStatus}</span>` : '';
            const coverIcon = contentType === 'comic' ? 'üìö' : 'üìñ';
            const ratingHtml = book.rating > 0 ? `<div class="star-rating-display">${renderStarsHtml(book.rating)}</div>` : '';
            return `
                <div class="book-card" data-book-id="${book.id}" onclick="handleBookClick(event, '${book.id}')">
                    <div class="book-cover">
                        ${typeBadgeHtml}
                        ${statusBadgeHtml}
                        <img src="${coverUrl}" alt="" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                        <div class="no-cover" style="display:none">${coverIcon}</div>
                    </div>
                    <div class="book-info">
                        <div class="book-title">${book.title}</div>
                        <div class="book-author">${book.author}</div>
                        ${book.series ? `<div class="book-series">${book.series} #${book.series_index}</div>` : ''}
                        ${ratingHtml}
                    </div>
                </div>
            `;
        }

        function renderStarsHtml(rating) {
            let html = '';
            for (let i = 1; i <= 5; i++) {
                html += `<span class="star${i <= rating ? ' filled' : ''}">‚òÖ</span>`;
            }
            return html;
        }

        // Handle book card click - prevent if long press triggered
        let longPressTriggered = false;
        function handleBookClick(event, bookId) {
            if (longPressTriggered) {
                longPressTriggered = false;
                event.preventDefault();
                return;
            }
            // Left click/tap goes directly to reader
            openReader(bookId);
        }

        function openReader(bookId) {
            window.location.href = `/reader/${bookId}`;
        }

        let currentBookId = null;

        async function openBookDetail(bookId) {
            currentBookId = bookId;
            const modal = document.getElementById('bookDetailModal');
            modal.classList.add('active');

            // Show loading state
            document.getElementById('detailTitle').textContent = 'Loading...';
            document.getElementById('detailAuthor').textContent = '';
            document.getElementById('detailSeries').textContent = '';
            document.getElementById('detailCover').innerHTML = '<div class="no-cover">‚è≥</div>';
            document.getElementById('metadataGrid').innerHTML = '';
            document.getElementById('metadataSource').textContent = '';
            document.getElementById('metadataUpdated').textContent = '';

            try {
                const res = await fetch(`${API_BASE}/books/${bookId}`, { headers: getAuthHeaders() });
                if (!res.ok) throw new Error('Failed to fetch book');
                const book = await res.json();
                currentBookData = book;
                renderBookDetail(book);
                // Update reading list button states
                updateReadingListButtons();
                // Load book tags
                loadBookTags();
                // Load book annotations
                loadBookAnnotations(bookId);
                // Load similar books
                loadSimilarBooks(bookId);
            } catch (err) {
                document.getElementById('detailTitle').textContent = 'Error loading book';
                console.error(err);
            }
        }

        async function loadSimilarBooks(bookId) {
            const section = document.getElementById('similarBooksSection');
            const grid = document.getElementById('similarBooksGrid');
            const countEl = document.getElementById('similarBooksCount');

            try {
                const res = await fetch(`${API_BASE}/books/${bookId}/similar?limit=8`, { headers: getAuthHeaders() });
                if (!res.ok) {
                    section.style.display = 'none';
                    return;
                }
                const data = await res.json();
                const similar = data.similar || [];

                if (similar.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                countEl.textContent = `(${similar.length})`;

                grid.innerHTML = similar.map(item => {
                    const book = item.book;
                    const coverHtml = book.id
                        ? `<img src="${API_BASE}/books/${book.id}/cover" alt="${book.title}" onerror="this.parentElement.innerHTML='<div class=\\'no-cover\\'>üìñ</div>'">`
                        : '<div class="no-cover">üìñ</div>';
                    const reason = item.reasons && item.reasons[0] ? item.reasons[0] : '';
                    return `
                        <div class="similar-book-card" onclick="openBookDetail('${book.id}')">
                            <div class="similar-book-cover">${coverHtml}</div>
                            <div class="similar-book-title">${book.title}</div>
                            <div class="similar-book-reason">${reason}</div>
                        </div>
                    `;
                }).join('');
            } catch (err) {
                console.error('Failed to load similar books:', err);
                section.style.display = 'none';
            }
        }

        async function loadBookAnnotations(bookId) {
            const section = document.getElementById('annotationsSection');
            const summary = document.getElementById('annotationsSummary');
            const countEl = document.getElementById('annotationCount');

            try {
                const res = await fetch(`${API_BASE}/books/${bookId}/annotations`, { headers: getAuthHeaders() });
                if (!res.ok) {
                    section.style.display = 'none';
                    return;
                }
                const data = await res.json();
                const annotations = data.annotations || [];

                if (annotations.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                countEl.textContent = `(${annotations.length})`;

                // Show up to 5 most recent annotations
                const recent = annotations.slice(0, 5);
                summary.innerHTML = recent.map(a => {
                    const truncatedText = a.selected_text.length > 80
                        ? a.selected_text.substring(0, 80) + '...'
                        : a.selected_text;
                    return `
                        <div class="annotation-preview ${a.color}">
                            <div class="annotation-preview-text">"${truncatedText}"</div>
                            ${a.note ? `<div class="annotation-preview-note">${a.note}</div>` : ''}
                            <div class="annotation-preview-meta">Chapter ${parseInt(a.chapter) + 1}</div>
                        </div>
                    `;
                }).join('');

                if (annotations.length > 5) {
                    summary.innerHTML += `<div style="text-align: center; color: var(--text-secondary); font-size: 12px; margin-top: 10px;">+ ${annotations.length - 5} more annotations</div>`;
                }
            } catch (err) {
                section.style.display = 'none';
                console.error('Failed to load annotations', err);
            }
        }

        function renderBookDetail(book) {
            const coverUrl = `${API_BASE}/books/${book.id}/cover`;
            const contentType = book.content_type || 'book';
            const coverIcon = contentType === 'comic' ? 'üìö' : 'üìñ';

            // Cover
            document.getElementById('detailCover').innerHTML = `
                <img src="${coverUrl}" alt="${book.title}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                <div class="no-cover" style="display:none">${coverIcon}</div>
            `;

            // Basic info
            document.getElementById('detailTitle').textContent = book.title;
            document.getElementById('detailAuthor').textContent = `by ${book.author}`;

            if (book.series) {
                document.getElementById('detailSeries').textContent = `${book.series} #${book.series_index}`;
                document.getElementById('detailSeries').style.display = 'block';
            } else {
                document.getElementById('detailSeries').style.display = 'none';
            }

            // Set read status
            document.getElementById('detailStatusSelect').value = book.read_status || 'unread';

            // Set star rating
            updateStarRatingDisplay(book.rating || 0);

            // Metadata source badge
            const sourceEl = document.getElementById('metadataSource');
            if (book.metadata_source) {
                sourceEl.textContent = book.metadata_source;
                let badgeClass = 'metadata-source-badge';
                if (book.metadata_source === 'openlibrary') badgeClass += ' openlibrary';
                else if (book.metadata_source === 'comicvine') badgeClass += ' comicvine';
                sourceEl.className = badgeClass;
                sourceEl.style.display = 'inline';
            } else {
                sourceEl.style.display = 'none';
            }

            // Build metadata grid
            let metadataHtml = '';

            // ISBN
            metadataHtml += renderMetadataRow('ISBN', book.isbn);

            // Publisher
            metadataHtml += renderMetadataRow('Publisher', book.publisher);

            // Publish Date
            metadataHtml += renderMetadataRow('Published', book.publish_date);

            // Language
            metadataHtml += renderMetadataRow('Language', book.language);

            // File size
            if (book.file_size) {
                const sizeStr = formatFileSize(book.file_size);
                metadataHtml += renderMetadataRow('File Size', sizeStr);
            }

            // Subjects
            if (book.subjects) {
                const subjects = book.subjects.split(',').map(s => s.trim()).filter(s => s);
                if (subjects.length > 0) {
                    const tagsHtml = subjects.map(s => `<span class="subject-tag">${s}</span>`).join('');
                    metadataHtml += `
                        <div class="metadata-label">Subjects</div>
                        <div class="metadata-value"><div class="subjects-list">${tagsHtml}</div></div>
                    `;
                }
            }

            // Description (full width)
            if (book.description) {
                metadataHtml += `
                    <div class="metadata-description">
                        <div class="metadata-label">Description</div>
                        <div class="metadata-value" id="descriptionText">${book.description}</div>
                    </div>
                `;
            }

            document.getElementById('metadataGrid').innerHTML = metadataHtml;

            // Metadata updated timestamp
            if (book.metadata_updated) {
                const date = new Date(book.metadata_updated);
                document.getElementById('metadataUpdated').textContent = `Metadata last updated: ${date.toLocaleDateString()}`;
            } else {
                document.getElementById('metadataUpdated').textContent = '';
            }
        }

        function renderMetadataRow(label, value) {
            if (value) {
                return `
                    <div class="metadata-label">${label}</div>
                    <div class="metadata-value">${value}</div>
                `;
            }
            return '';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function closeBookDetailModal() {
            document.getElementById('bookDetailModal').classList.remove('active');
            document.getElementById('refreshResult').innerHTML = '';
            currentBookId = null;
            // Reset reading list buttons
            document.getElementById('wantToReadBtn').classList.remove('active');
            document.getElementById('favoritesBtn').classList.remove('active');
            // Reset tags
            currentBookTags = [];
            document.getElementById('noTagsMsg').style.display = 'inline';
            document.getElementById('bookTagsContainer').querySelectorAll('.tag-chip').forEach(el => el.remove());
            document.getElementById('tagDropdown').classList.remove('show');
        }

        let currentBookData = null;
        let userReadingLists = null; // Cache for user's reading lists

        // Load user's reading lists
        async function loadReadingLists() {
            if (!isAuthenticated()) {
                document.getElementById('readingListsSection').style.display = 'none';
                return;
            }

            document.getElementById('readingListsSection').style.display = 'flex';

            try {
                const res = await fetch(`${API_BASE}/reading-lists`, { headers: getAuthHeaders() });
                if (res.ok) {
                    const data = await res.json();
                    userReadingLists = data.lists || [];
                }
            } catch (err) {
                console.error('Failed to load reading lists:', err);
            }
        }

        // Check if current book is in reading lists and update button states
        async function updateReadingListButtons() {
            if (!currentBookId || !isAuthenticated()) return;

            // Reset buttons first
            document.getElementById('wantToReadBtn').classList.remove('active');
            document.getElementById('favoritesBtn').classList.remove('active');

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/reading-lists`, { headers: getAuthHeaders() });
                if (res.ok) {
                    const data = await res.json();
                    const lists = data.lists || [];

                    lists.forEach(list => {
                        if (list.list_type === 'want_to_read') {
                            document.getElementById('wantToReadBtn').classList.add('active');
                        } else if (list.list_type === 'favorites') {
                            document.getElementById('favoritesBtn').classList.add('active');
                        }
                    });
                }
            } catch (err) {
                console.error('Failed to check reading lists:', err);
            }
        }

        // Toggle a book in a reading list
        async function toggleReadingList(listType) {
            if (!currentBookId || !isAuthenticated()) {
                alert('Please log in to use reading lists');
                return;
            }

            // Ensure reading lists are loaded
            if (!userReadingLists) {
                await loadReadingLists();
            }

            // Find the list ID for this type
            const list = userReadingLists?.find(l => l.list_type === listType);
            if (!list) {
                console.error('Reading list not found:', listType);
                return;
            }

            const btn = listType === 'want_to_read' ? document.getElementById('wantToReadBtn') : document.getElementById('favoritesBtn');

            try {
                const res = await fetch(`${API_BASE}/reading-lists/${list.id}/books/${currentBookId}/toggle`, {
                    method: 'PUT',
                    headers: getAuthHeaders()
                });

                if (res.ok) {
                    const data = await res.json();
                    if (data.in_list) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                } else {
                    const data = await res.json();
                    alert(data.error || 'Failed to update reading list');
                }
            } catch (err) {
                console.error('Failed to toggle reading list:', err);
                alert('Failed to update reading list');
            }
        }

        // Quick toggle reading list for swipe actions
        async function quickToggleReadingList(bookId, listType) {
            if (!isAuthenticated()) {
                showToast('Please log in to use reading lists', 'error');
                return;
            }

            // Ensure reading lists are loaded
            if (!userReadingLists) {
                await loadReadingLists();
            }

            const list = userReadingLists?.find(l => l.list_type === listType);
            if (!list) {
                showToast('Reading list not found', 'error');
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/reading-lists/${list.id}/books/${bookId}/toggle`, {
                    method: 'PUT',
                    headers: getAuthHeaders()
                });

                if (res.ok) {
                    const data = await res.json();
                    const book = books.find(b => b.id === bookId);
                    const title = book?.title || 'Book';
                    if (data.in_list) {
                        showToast(`Added "${title}" to Want to Read`, 'success');
                    } else {
                        showToast(`Removed "${title}" from Want to Read`, 'info');
                    }
                } else {
                    showToast('Failed to update reading list', 'error');
                }
            } catch (err) {
                console.error('Failed to toggle reading list:', err);
                showToast('Failed to update reading list', 'error');
            }
        }

        // Star rating functions
        function updateStarRatingDisplay(rating) {
            const container = document.getElementById('detailStarRating');
            if (!container) return;

            const stars = container.querySelectorAll('.star');
            stars.forEach((star, index) => {
                if (index < rating) {
                    star.classList.add('filled');
                } else {
                    star.classList.remove('filled');
                }
            });
        }

        function initStarRating() {
            const container = document.getElementById('detailStarRating');
            if (!container) return;

            const stars = container.querySelectorAll('.star');

            // Hover effects
            stars.forEach((star, index) => {
                star.addEventListener('mouseenter', () => {
                    stars.forEach((s, i) => {
                        if (i <= index) {
                            s.classList.add('hover');
                        } else {
                            s.classList.remove('hover');
                        }
                    });
                });

                star.addEventListener('mouseleave', () => {
                    stars.forEach(s => s.classList.remove('hover'));
                });

                // Click to set rating
                star.addEventListener('click', async () => {
                    const value = parseInt(star.dataset.value);
                    await saveBookRating(value);
                });
            });

            // Click outside to clear (optional - click on label to clear)
            const label = container.parentElement.querySelector('label');
            if (label) {
                label.style.cursor = 'pointer';
                label.title = 'Click to clear rating';
                label.addEventListener('click', async () => {
                    await saveBookRating(0);
                });
            }
        }

        async function saveBookRating(rating) {
            if (!currentBookId) return;

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/rating`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getAuthHeaders()
                    },
                    body: JSON.stringify({ rating })
                });

                if (res.ok) {
                    updateStarRatingDisplay(rating);
                    // Update cached book data
                    if (currentBookData) {
                        currentBookData.rating = rating;
                    }
                    // Refresh the library to show updated rating
                    loadBooks();
                } else {
                    const data = await res.json();
                    alert(data.error || 'Failed to save rating');
                }
            } catch (err) {
                console.error('Failed to save rating:', err);
                alert('Failed to save rating');
            }
        }

        // ==================== Tag Functions ====================

        let userTags = null; // Cache for user's tags
        let currentBookTags = []; // Tags on the current book

        // Load all user's tags
        async function loadUserTags() {
            const tagSelect = document.getElementById('tagSelect');

            if (!isAuthenticated()) {
                document.getElementById('tagsSection').style.display = 'none';
                tagSelect.style.display = 'none';
                return;
            }

            document.getElementById('tagsSection').style.display = 'block';
            tagSelect.style.display = 'block';

            try {
                const res = await fetch(`${API_BASE}/tags`, { headers: getAuthHeaders() });
                if (res.ok) {
                    const data = await res.json();
                    userTags = data.tags || [];
                    // Populate tag filter dropdown
                    populateTagFilter();
                }
            } catch (err) {
                console.error('Failed to load tags:', err);
            }
        }

        // Populate the tag filter dropdown
        function populateTagFilter() {
            const tagSelect = document.getElementById('tagSelect');
            const currentValue = tagSelect.value;

            // Clear existing options except first
            tagSelect.innerHTML = '<option value="">All Tags</option>';

            if (userTags && userTags.length > 0) {
                userTags.forEach(tag => {
                    const option = document.createElement('option');
                    option.value = tag.id;
                    option.textContent = tag.name;
                    tagSelect.appendChild(option);
                });
            }

            // Restore selection if still valid
            if (currentValue && userTags?.some(t => t.id === currentValue)) {
                tagSelect.value = currentValue;
            }
        }

        // Load tags for the current book
        async function loadBookTags() {
            if (!currentBookId || !isAuthenticated()) return;

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/tags`, { headers: getAuthHeaders() });
                if (res.ok) {
                    const data = await res.json();
                    currentBookTags = data.tags || [];
                    renderBookTags();
                }
            } catch (err) {
                console.error('Failed to load book tags:', err);
            }
        }

        // Render the tags on the current book
        function renderBookTags() {
            const container = document.getElementById('bookTagsContainer');
            const noTagsMsg = document.getElementById('noTagsMsg');
            const dropdown = container.querySelector('.tag-dropdown');

            // Remove existing tag chips (but keep no-tags message and dropdown)
            container.querySelectorAll('.tag-chip').forEach(el => el.remove());

            if (currentBookTags.length === 0) {
                noTagsMsg.style.display = 'inline';
            } else {
                noTagsMsg.style.display = 'none';
                currentBookTags.forEach(tag => {
                    const chip = document.createElement('span');
                    chip.className = 'tag-chip';
                    chip.style.backgroundColor = tag.color + '20';
                    chip.style.color = tag.color;
                    chip.style.borderColor = tag.color;
                    chip.innerHTML = `${tag.name}<span class="remove-tag" onclick="removeTagFromBook('${tag.id}')">&times;</span>`;
                    container.insertBefore(chip, dropdown);
                });
            }
        }

        // Toggle tag dropdown
        function toggleTagDropdown(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('tagDropdown');
            dropdown.classList.toggle('show');
            if (dropdown.classList.contains('show')) {
                document.getElementById('tagSearchInput').value = '';
                document.getElementById('tagSearchInput').focus();
                renderTagDropdown('');
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('tagDropdown');
            if (dropdown && !e.target.closest('.tag-dropdown')) {
                dropdown.classList.remove('show');
            }
        });

        // Filter and render tag dropdown
        function filterTags(query) {
            renderTagDropdown(query);
        }

        // Render the tag dropdown list
        function renderTagDropdown(query) {
            const list = document.getElementById('tagDropdownList');
            const filtered = (userTags || []).filter(tag =>
                tag.name.toLowerCase().includes(query.toLowerCase()) &&
                !currentBookTags.some(bt => bt.id === tag.id)
            );

            let html = '';

            filtered.forEach(tag => {
                html += `
                    <div class="tag-dropdown-item" onclick="addTagToBook('${tag.id}')">
                        <span class="tag-color" style="background-color: ${tag.color}"></span>
                        <span>${tag.name}</span>
                    </div>
                `;
            });

            // Show create option if query doesn't match existing tag
            const queryTrimmed = query.trim();
            if (queryTrimmed && !userTags?.some(t => t.name.toLowerCase() === queryTrimmed.toLowerCase())) {
                html += `
                    <div class="tag-dropdown-item create-new" onclick="createAndAddTag('${queryTrimmed.replace(/'/g, "\\'")}')">
                        + Create "${queryTrimmed}"
                    </div>
                `;
            }

            if (!html) {
                html = '<div class="tag-dropdown-item" style="color: var(--text-secondary); cursor: default;">No tags available</div>';
            }

            list.innerHTML = html;
        }

        // Add existing tag to book
        async function addTagToBook(tagId) {
            if (!currentBookId) return;

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/tags/${tagId}`, {
                    method: 'POST',
                    headers: getAuthHeaders()
                });

                if (res.ok) {
                    await loadBookTags();
                    document.getElementById('tagDropdown').classList.remove('show');
                } else {
                    const data = await res.json();
                    alert(data.error || 'Failed to add tag');
                }
            } catch (err) {
                console.error('Failed to add tag:', err);
                alert('Failed to add tag');
            }
        }

        // Remove tag from book
        async function removeTagFromBook(tagId) {
            if (!currentBookId) return;

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/tags/${tagId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.ok) {
                    await loadBookTags();
                } else {
                    const data = await res.json();
                    alert(data.error || 'Failed to remove tag');
                }
            } catch (err) {
                console.error('Failed to remove tag:', err);
                alert('Failed to remove tag');
            }
        }

        // Create a new tag and add it to the book
        async function createAndAddTag(name) {
            if (!currentBookId) return;

            // Generate a random color
            const colors = ['#3b82f6', '#ef4444', '#22c55e', '#f59e0b', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
            const color = colors[Math.floor(Math.random() * colors.length)];

            try {
                // Create tag
                const createRes = await fetch(`${API_BASE}/tags`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getAuthHeaders()
                    },
                    body: JSON.stringify({ name, color })
                });

                if (createRes.ok) {
                    const data = await createRes.json();
                    const newTag = data.tag;

                    // Add to user tags cache
                    if (userTags) userTags.push(newTag);

                    // Add to book
                    await addTagToBook(newTag.id);
                } else {
                    const data = await createRes.json();
                    // If tag already exists, try to add it
                    if (data.tag) {
                        await addTagToBook(data.tag.id);
                    } else {
                        alert(data.error || 'Failed to create tag');
                    }
                }
            } catch (err) {
                console.error('Failed to create tag:', err);
                alert('Failed to create tag');
            }
        }

        function openEditModal() {
            if (!currentBookData) return;

            // Populate form with current data
            document.getElementById('editTitle').value = currentBookData.title || '';
            document.getElementById('editAuthor').value = currentBookData.author || '';
            document.getElementById('editSeries').value = currentBookData.series || '';
            document.getElementById('editSeriesIndex').value = currentBookData.series_index || '';
            document.getElementById('editISBN').value = currentBookData.isbn || '';
            document.getElementById('editPublisher').value = currentBookData.publisher || '';
            document.getElementById('editPublishDate').value = currentBookData.publish_date || '';
            document.getElementById('editLanguage').value = currentBookData.language || '';
            document.getElementById('editSubjects').value = currentBookData.subjects || '';
            document.getElementById('editDescription').value = currentBookData.description || '';

            // Clear any previous errors
            document.querySelectorAll('.form-group.error').forEach(el => el.classList.remove('error'));
            document.querySelectorAll('.error-message').forEach(el => el.remove());

            document.getElementById('editMetadataModal').classList.add('active');
        }

        function closeEditModal() {
            document.getElementById('editMetadataModal').classList.remove('active');
        }

        function validateISBN(isbn) {
            if (!isbn) return true; // Empty is OK
            const cleaned = isbn.replace(/[-\s]/g, '');
            // ISBN-10 or ISBN-13
            if (cleaned.length === 10) {
                return /^\d{9}[\dXx]$/.test(cleaned);
            } else if (cleaned.length === 13) {
                return /^\d{13}$/.test(cleaned);
            }
            return false;
        }

        async function saveMetadata(e) {
            e.preventDefault();

            if (!currentBookId) return;

            // Clear previous errors
            document.querySelectorAll('.form-group.error').forEach(el => el.classList.remove('error'));
            document.querySelectorAll('.error-message').forEach(el => el.remove());

            // Validate ISBN
            const isbnInput = document.getElementById('editISBN');
            const isbn = isbnInput.value.trim();
            if (isbn && !validateISBN(isbn)) {
                const group = isbnInput.closest('.form-group');
                group.classList.add('error');
                const errMsg = document.createElement('div');
                errMsg.className = 'error-message';
                errMsg.textContent = 'Invalid ISBN format (must be 10 or 13 digits)';
                group.appendChild(errMsg);
                isbnInput.focus();
                return;
            }

            const saveBtn = document.getElementById('saveEditBtn');
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            const formData = {
                title: document.getElementById('editTitle').value.trim(),
                author: document.getElementById('editAuthor').value.trim(),
                series: document.getElementById('editSeries').value.trim(),
                series_index: parseFloat(document.getElementById('editSeriesIndex').value) || 0,
                isbn: isbn,
                publisher: document.getElementById('editPublisher').value.trim(),
                publish_date: document.getElementById('editPublishDate').value.trim(),
                language: document.getElementById('editLanguage').value.trim(),
                subjects: document.getElementById('editSubjects').value.trim(),
                description: document.getElementById('editDescription').value.trim()
            };

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/metadata`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getAuthHeaders()
                    },
                    body: JSON.stringify(formData)
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.error || 'Failed to save changes');
                }

                const data = await res.json();

                // Close edit modal
                closeEditModal();

                // Refresh the book detail
                if (data.book) {
                    renderBookDetail(data.book);
                    currentBookData = data.book;
                }

                // Show success message
                document.getElementById('refreshResult').innerHTML = `
                    <div class="refresh-result success">
                        Metadata saved successfully!
                    </div>
                `;
            } catch (err) {
                alert(err.message);
            } finally {
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Changes';
            }
        }

        async function refreshMetadata() {
            if (!currentBookId || !currentBookData) return;

            const btn = document.getElementById('refreshMetadataBtn');
            const resultDiv = document.getElementById('refreshResult');

            // Show loading state
            btn.classList.add('loading');
            btn.disabled = true;
            resultDiv.innerHTML = '';

            // Use comic endpoint for comics, book endpoint for books
            const isComic = currentBookData.content_type === 'comic';
            const endpoint = isComic
                ? `${API_BASE}/books/${currentBookId}/metadata/comic/refresh`
                : `${API_BASE}/books/${currentBookId}/metadata/refresh`;

            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    headers: getAuthHeaders()
                });

                const data = await res.json();

                if (res.status === 429) {
                    // Rate limited
                    resultDiv.innerHTML = `
                        <div class="refresh-result error">
                            Rate limited. Please wait a moment and try again.
                        </div>
                    `;
                } else if (res.status === 503) {
                    // Service not configured (e.g., ComicVine API key missing)
                    resultDiv.innerHTML = `
                        <div class="refresh-result warning">
                            ${data.message || 'Metadata service not configured. Contact your administrator.'}
                        </div>
                    `;
                } else if (res.status === 404) {
                    // No match found
                    resultDiv.innerHTML = `
                        <div class="refresh-result warning">
                            No matching metadata found. Try editing the title or ISBN manually.
                        </div>
                    `;
                } else if (!res.ok) {
                    // Other error
                    resultDiv.innerHTML = `
                        <div class="refresh-result error">
                            ${data.error || 'Failed to refresh metadata'}
                        </div>
                    `;
                } else {
                    // Success
                    const confidence = data.confidence || 0;
                    const confidencePercent = Math.round(confidence * 100);
                    const confidenceClass = confidence >= 0.7 ? 'high' : confidence >= 0.5 ? 'medium' : 'low';

                    if (confidence < 0.5) {
                        // Low confidence warning
                        resultDiv.innerHTML = `
                            <div class="refresh-result warning">
                                <strong>Low confidence match (${confidencePercent}%)</strong>
                                <p style="margin-top: 5px;">${data.message}</p>
                                <div class="confidence-bar">
                                    <div class="confidence-fill ${confidenceClass}" style="width: ${confidencePercent}%"></div>
                                </div>
                            </div>
                        `;
                    } else {
                        // Good match
                        resultDiv.innerHTML = `
                            <div class="refresh-result success">
                                <strong>Metadata updated!</strong> (${confidencePercent}% confidence from ${data.source})
                                <div class="confidence-bar">
                                    <div class="confidence-fill ${confidenceClass}" style="width: ${confidencePercent}%"></div>
                                </div>
                            </div>
                        `;
                        // Refresh the book details
                        if (data.book) {
                            renderBookDetail(data.book);
                        }
                    }
                }
            } catch (err) {
                resultDiv.innerHTML = `
                    <div class="refresh-result error">
                        Network error. Please check your connection.
                    </div>
                `;
                console.error(err);
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        }

        // Search Metadata functionality
        let searchResults = [];
        let selectedMetadata = null;

        function openSearchModal() {
            if (!currentBookData) return;

            // Pre-fill search fields with current book data
            document.getElementById('searchTitle').value = currentBookData.title || '';
            document.getElementById('searchAuthor').value = currentBookData.author || '';
            document.getElementById('searchISBN').value = currentBookData.isbn || '';

            // Reset search state
            searchResults = [];
            selectedMetadata = null;
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('selectedPreview').style.display = 'none';
            document.getElementById('resultsContainer').innerHTML = '';

            document.getElementById('searchMetadataModal').classList.add('active');
        }

        function closeSearchModal() {
            document.getElementById('searchMetadataModal').classList.remove('active');
            searchResults = [];
            selectedMetadata = null;
        }

        async function performSearch() {
            const title = document.getElementById('searchTitle').value.trim();
            const author = document.getElementById('searchAuthor').value.trim();
            const isbn = document.getElementById('searchISBN').value.trim();
            const year = document.getElementById('searchYear').value.trim();
            const seriesNum = document.getElementById('searchSeriesNum').value.trim();

            if (!title && !author && !isbn) {
                alert('Please enter at least a title, author, or ISBN to search');
                return;
            }

            const btn = document.getElementById('doSearchBtn');
            const resultsDiv = document.getElementById('searchResults');
            const container = document.getElementById('resultsContainer');

            btn.disabled = true;
            btn.textContent = 'Searching...';
            resultsDiv.style.display = 'block';
            document.getElementById('selectedPreview').style.display = 'none';
            container.innerHTML = '<div class="search-loading">Searching for metadata...</div>';

            try {
                const params = new URLSearchParams();
                if (isbn) params.append('isbn', isbn);
                if (title) params.append('title', title);
                if (author) params.append('author', author);
                if (year) params.append('year', year);
                if (seriesNum) params.append('series_num', seriesNum);

                const res = await fetch(`${API_BASE}/metadata/search?${params}`, {
                    headers: getAuthHeaders()
                });

                if (res.status === 429) {
                    container.innerHTML = '<div class="search-error">Rate limited. Please wait a moment and try again.</div>';
                    return;
                }

                if (res.status === 404) {
                    container.innerHTML = '<div class="no-results">No matching metadata found. Try different search terms.</div>';
                    return;
                }

                if (!res.ok) {
                    const data = await res.json();
                    container.innerHTML = `<div class="search-error">${data.error || 'Search failed'}</div>`;
                    return;
                }

                const data = await res.json();
                searchResults = data.results || [];

                if (searchResults.length === 0) {
                    container.innerHTML = '<div class="no-results">No matching metadata found. Try different search terms.</div>';
                    return;
                }

                renderSearchResults();
            } catch (err) {
                container.innerHTML = '<div class="search-error">Network error. Please check your connection.</div>';
                console.error(err);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Search';
            }
        }

        function renderSearchResults() {
            const container = document.getElementById('resultsContainer');

            container.innerHTML = searchResults.map((result, index) => {
                const confidence = result.confidence || 0;
                const confidenceClass = confidence >= 0.7 ? 'high' : confidence >= 0.5 ? 'medium' : 'low';
                const confidencePercent = Math.round(confidence * 100);
                const authors = result.authors ? result.authors.join(', ') : '';

                return `
                    <div class="result-item" onclick="selectSearchResult(${index})">
                        <div class="result-title">${result.title || 'Unknown Title'}</div>
                        <div class="result-author">${authors || 'Unknown Author'}</div>
                        <div class="result-details">
                            ${result.isbn13 ? `<span>ISBN: ${result.isbn13}</span>` : ''}
                            ${result.publish_date ? `<span>${result.publish_date}</span>` : ''}
                            ${result.publisher ? `<span>${result.publisher}</span>` : ''}
                            <span class="result-confidence">
                                <span class="confidence-dot ${confidenceClass}"></span>
                                ${confidencePercent}% match
                            </span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function selectSearchResult(index) {
            selectedMetadata = searchResults[index];
            showMetadataPreview();
        }

        function showMetadataPreview() {
            if (!selectedMetadata) return;

            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('selectedPreview').style.display = 'block';

            const previewContent = document.getElementById('previewContent');
            const meta = selectedMetadata;
            const authors = meta.authors ? meta.authors.join(', ') : '';
            const subjects = meta.subjects ? meta.subjects.join(', ') : '';

            let html = '<div class="preview-grid">';
            html += `<div class="preview-label">Title</div><div class="preview-value">${meta.title || '-'}</div>`;
            html += `<div class="preview-label">Author</div><div class="preview-value">${authors || '-'}</div>`;
            if (meta.isbn13 || meta.isbn10) {
                html += `<div class="preview-label">ISBN</div><div class="preview-value">${meta.isbn13 || meta.isbn10}</div>`;
            }
            if (meta.publisher) {
                html += `<div class="preview-label">Publisher</div><div class="preview-value">${meta.publisher}</div>`;
            }
            if (meta.publish_date) {
                html += `<div class="preview-label">Published</div><div class="preview-value">${meta.publish_date}</div>`;
            }
            if (meta.language) {
                html += `<div class="preview-label">Language</div><div class="preview-value">${meta.language}</div>`;
            }
            if (subjects) {
                html += `<div class="preview-label">Subjects</div><div class="preview-value">${subjects}</div>`;
            }
            if (meta.description) {
                html += `<div class="preview-description">
                    <div class="preview-label">Description</div>
                    <div class="preview-value">${meta.description}</div>
                </div>`;
            }
            html += '</div>';

            previewContent.innerHTML = html;
        }

        function backToResults() {
            document.getElementById('selectedPreview').style.display = 'none';
            document.getElementById('searchResults').style.display = 'block';
        }

        async function applySelectedMetadata() {
            if (!selectedMetadata || !currentBookId) return;

            const btn = document.getElementById('applyMetadataBtn');
            btn.disabled = true;
            btn.textContent = 'Applying...';

            const meta = selectedMetadata;
            const formData = {
                title: meta.title || currentBookData.title,
                author: meta.authors ? meta.authors[0] : currentBookData.author,
                series: currentBookData.series, // Keep existing series
                series_index: currentBookData.series_index,
                isbn: meta.isbn13 || meta.isbn10 || '',
                publisher: meta.publisher || '',
                publish_date: meta.publish_date || '',
                language: meta.language || '',
                subjects: meta.subjects ? meta.subjects.join(', ') : '',
                description: meta.description || ''
            };

            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/metadata`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getAuthHeaders()
                    },
                    body: JSON.stringify(formData)
                });

                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.error || 'Failed to apply metadata');
                }

                const data = await res.json();

                // Close search modal
                closeSearchModal();

                // Refresh the book detail
                if (data.book) {
                    renderBookDetail(data.book);
                    currentBookData = data.book;
                }

                // Show success message
                document.getElementById('refreshResult').innerHTML = `
                    <div class="refresh-result success">
                        Metadata applied successfully from ${meta.source || 'search'}!
                    </div>
                `;
            } catch (err) {
                alert(err.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Apply to Book';
            }
        }

        // Batch upload state
        let batchUploadState = {
            files: [],
            results: [],
            completed: 0,
            total: 0,
            isUploading: false
        };

        async function handleBatchUpload(files) {
            if (files.length === 0) return;

            // Reset state
            batchUploadState = {
                files: Array.from(files),
                results: [],
                completed: 0,
                total: files.length,
                isUploading: true
            };

            // Show batch upload section
            document.getElementById('batchUploadSection').style.display = 'block';
            document.getElementById('importSummary').style.display = 'none';
            document.getElementById('dropZone').style.display = 'none';
            document.getElementById('clearUploadBtn').style.display = 'none';

            // Initialize file list UI
            const fileList = document.getElementById('fileUploadList');
            fileList.innerHTML = batchUploadState.files.map((file, idx) => `
                <div id="uploadItem-${idx}" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid var(--border-color);">
                    <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <span style="font-size: 13px;">${file.name}</span>
                        <span style="font-size: 11px; color: var(--text-muted); margin-left: 8px;">${formatFileSize(file.size)}</span>
                    </div>
                    <div id="uploadStatus-${idx}" style="font-size: 12px; color: var(--text-muted);">Waiting...</div>
                </div>
            `).join('');

            updateBatchProgress();

            // Upload files sequentially (to avoid overwhelming the server)
            for (let i = 0; i < batchUploadState.files.length; i++) {
                if (!batchUploadState.isUploading) break; // Allow cancellation
                await uploadSingleFile(batchUploadState.files[i], i);
            }

            // Show summary
            showImportSummary();
            batchUploadState.isUploading = false;
        }

        async function uploadSingleFile(file, index) {
            const statusEl = document.getElementById(`uploadStatus-${index}`);
            const itemEl = document.getElementById(`uploadItem-${index}`);

            statusEl.textContent = 'Uploading...';
            statusEl.style.color = 'var(--accent-color)';

            const formData = new FormData();
            formData.append('file', file);

            try {
                // Remove Content-Type from headers for FormData (browser sets it with boundary)
                const headers = getAuthHeaders();
                delete headers['Content-Type'];

                const result = await fetch(`${API_BASE}/books`, {
                    method: 'POST',
                    headers: headers,
                    body: formData
                });

                if (result.status === 201) {
                    const book = await result.json();
                    statusEl.textContent = '‚úì Success';
                    statusEl.style.color = '#28a745';
                    itemEl.style.background = 'rgba(40, 167, 69, 0.1)';
                    batchUploadState.results.push({ file: file.name, status: 'success', book });

                    // Auto-fetch metadata if enabled
                    if (document.getElementById('autoMetadataFetch').checked && book.id) {
                        try {
                            await fetch(`${API_BASE}/books/${book.id}/metadata/refresh`, {
                                method: 'POST',
                                headers: getAuthHeaders()
                            });
                        } catch (e) {
                            // Silently ignore metadata fetch errors
                        }
                    }
                } else {
                    const error = await result.json();
                    statusEl.textContent = '‚úó ' + (error.error || 'Failed');
                    statusEl.style.color = '#dc3545';
                    itemEl.style.background = 'rgba(220, 53, 69, 0.1)';
                    batchUploadState.results.push({ file: file.name, status: 'failed', error: error.error || 'Upload failed' });
                }
            } catch (err) {
                statusEl.textContent = '‚úó Error';
                statusEl.style.color = '#dc3545';
                itemEl.style.background = 'rgba(220, 53, 69, 0.1)';
                batchUploadState.results.push({ file: file.name, status: 'failed', error: err.message });
            }

            batchUploadState.completed++;
            updateBatchProgress();
        }

        function updateBatchProgress() {
            const percent = batchUploadState.total > 0
                ? (batchUploadState.completed / batchUploadState.total) * 100
                : 0;
            document.getElementById('batchProgressFill').style.width = percent + '%';
            document.getElementById('batchUploadSummary').textContent =
                `${batchUploadState.completed} of ${batchUploadState.total} files processed`;
        }

        function showImportSummary() {
            const successCount = batchUploadState.results.filter(r => r.status === 'success').length;
            const failedResults = batchUploadState.results.filter(r => r.status === 'failed');
            const skippedCount = batchUploadState.results.filter(r => r.status === 'skipped').length;

            document.getElementById('successCount').textContent = successCount;
            document.getElementById('failedCount').textContent = failedResults.length;
            document.getElementById('skippedCount').textContent = skippedCount;

            // Show failed files if any
            const failedList = document.getElementById('failedFilesList');
            if (failedResults.length > 0) {
                failedList.style.display = 'block';
                failedList.innerHTML = failedResults.map(r =>
                    `<div>${r.file}: ${r.error}</div>`
                ).join('');
                document.getElementById('retryFailedBtn').style.display = 'inline-block';
            } else {
                failedList.style.display = 'none';
                document.getElementById('retryFailedBtn').style.display = 'none';
            }

            document.getElementById('importSummary').style.display = 'block';
            document.getElementById('clearUploadBtn').style.display = 'inline-block';

            // Reload books
            loadBooks();
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function resetUploadModal() {
            document.getElementById('batchUploadSection').style.display = 'none';
            document.getElementById('importSummary').style.display = 'none';
            document.getElementById('dropZone').style.display = 'block';
            document.getElementById('clearUploadBtn').style.display = 'none';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileUploadList').innerHTML = '';
            document.getElementById('batchProgressFill').style.width = '0%';
            batchUploadState = { files: [], results: [], completed: 0, total: 0, isUploading: false };
        }

        function closeUploadModal() {
            document.getElementById('uploadModal').classList.remove('active');
            // Don't reset immediately in case user wants to see results
            if (!batchUploadState.isUploading) {
                setTimeout(resetUploadModal, 300);
            }
        }

        // Legacy single file upload (kept for compatibility)
        async function uploadFile(file) {
            handleBatchUpload([file]);
        }

        // Event Listeners
        // Book Detail Modal Event Listeners
        document.getElementById('readBookBtn').addEventListener('click', () => {
            if (currentBookId) {
                openReader(currentBookId);
            }
        });

        document.getElementById('closeDetailBtn').addEventListener('click', closeBookDetailModal);

        document.getElementById('refreshMetadataBtn').addEventListener('click', refreshMetadata);

        document.getElementById('bookDetailModal').addEventListener('click', (e) => {
            if (e.target.id === 'bookDetailModal') closeBookDetailModal();
        });

        // Read status change in detail modal
        document.getElementById('detailStatusSelect').addEventListener('change', async (e) => {
            if (!currentBookId) return;

            const newStatus = e.target.value;
            try {
                const res = await fetch(`${API_BASE}/books/${currentBookId}/status`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        ...getAuthHeaders()
                    },
                    body: JSON.stringify({ status: newStatus })
                });

                if (res.ok) {
                    // Update current book data
                    if (currentBookData) {
                        currentBookData.read_status = newStatus;
                    }
                    // Refresh library to show updated status
                    loadBooks();
                } else {
                    const data = await res.json();
                    alert(data.error || 'Failed to update status');
                    // Revert select to previous value
                    e.target.value = currentBookData?.read_status || 'unread';
                }
            } catch (err) {
                console.error(err);
                alert('Failed to update status');
                e.target.value = currentBookData?.read_status || 'unread';
            }
        });

        // Edit Metadata Modal Event Listeners
        document.getElementById('editMetadataBtn').addEventListener('click', openEditModal);

        document.getElementById('cancelEditBtn').addEventListener('click', closeEditModal);

        document.getElementById('editMetadataForm').addEventListener('submit', saveMetadata);

        document.getElementById('editMetadataModal').addEventListener('click', (e) => {
            if (e.target.id === 'editMetadataModal') closeEditModal();
        });

        document.getElementById('searchFromEditBtn').addEventListener('click', () => {
            // Open search modal from edit modal context
            openSearchModal();
        });

        // Search Metadata Modal Event Listeners
        document.getElementById('searchMetadataBtn').addEventListener('click', openSearchModal);

        document.getElementById('cancelSearchBtn').addEventListener('click', closeSearchModal);

        document.getElementById('doSearchBtn').addEventListener('click', performSearch);

        document.getElementById('backToResultsBtn').addEventListener('click', backToResults);

        document.getElementById('applyMetadataBtn').addEventListener('click', applySelectedMetadata);

        document.getElementById('searchMetadataModal').addEventListener('click', (e) => {
            if (e.target.id === 'searchMetadataModal') closeSearchModal();
        });

        // Collections functionality
        let currentViewingCollectionId = null;

        async function loadCollections() {
            const listContainer = document.getElementById('collectionsList');
            try {
                const res = await fetch(`${API_BASE}/collections`, { headers: getAuthHeaders() });
                const data = await res.json();

                if (!data.collections || data.collections.length === 0) {
                    listContainer.innerHTML = '<p style="color: var(--text-secondary);">No collections yet. Create one!</p>';
                    return;
                }

                listContainer.innerHTML = data.collections.map(c => `
                    <div class="collection-item" data-id="${c.id}" style="
                        padding: 12px;
                        background: var(--card-bg);
                        border-radius: 8px;
                        cursor: pointer;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <div>
                            <strong>${c.name}</strong>
                            ${c.is_smart ? '<span style="margin-left: 8px; padding: 2px 6px; background: var(--accent-color); color: white; border-radius: 4px; font-size: 10px;">SMART</span>' : ''}
                        </div>
                        <span style="color: var(--text-secondary); font-size: 12px;">${c.book_count || 0} books</span>
                    </div>
                `).join('');

                // Add click handlers
                listContainer.querySelectorAll('.collection-item').forEach(item => {
                    item.addEventListener('click', () => openViewCollection(item.dataset.id));
                });
            } catch (err) {
                listContainer.innerHTML = '<p style="color: red;">Failed to load collections</p>';
                console.error(err);
            }
        }

        async function openViewCollection(collectionId) {
            currentViewingCollectionId = collectionId;
            document.getElementById('collectionsModal').classList.remove('active');
            document.getElementById('viewCollectionModal').classList.add('active');

            const booksContainer = document.getElementById('viewCollectionBooks');
            booksContainer.innerHTML = '<div class="loading">Loading...</div>';

            try {
                const res = await fetch(`${API_BASE}/collections/${collectionId}`, { headers: getAuthHeaders() });
                const data = await res.json();

                document.getElementById('viewCollectionName').textContent = data.collection.name;
                document.getElementById('viewCollectionBadge').textContent = data.collection.is_smart ? 'Smart Collection' : 'Manual Collection';

                // Show rules if smart collection
                const rulesDiv = document.getElementById('viewCollectionRules');
                if (data.collection.is_smart && data.collection.rules && data.collection.rules.length > 0) {
                    rulesDiv.style.display = 'block';
                    const rulesText = data.collection.rules.map(r =>
                        `${r.field} ${r.operator} "${r.value}"`
                    ).join(data.collection.rule_logic === 'OR' ? ' OR ' : ' AND ');
                    document.getElementById('viewCollectionRulesText').textContent = rulesText;
                } else {
                    rulesDiv.style.display = 'none';
                }

                if (!data.books || data.books.length === 0) {
                    booksContainer.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1/-1;">No books match this collection.</p>';
                    return;
                }

                booksContainer.innerHTML = data.books.map(book => `
                    <div class="book-card" onclick="openBookDetail('${book.id}')" style="cursor: pointer;">
                        <div class="book-cover">
                            <img src="${API_BASE}/books/${book.id}/cover" alt=""
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="no-cover" style="display: none;">${book.content_type === 'comic' ? 'üìö' : 'üìñ'}</div>
                        </div>
                        <div class="book-info">
                            <div class="book-title">${book.title}</div>
                            <div class="book-author">${book.author || 'Unknown'}</div>
                        </div>
                    </div>
                `).join('');
            } catch (err) {
                booksContainer.innerHTML = '<p style="color: red;">Failed to load collection</p>';
                console.error(err);
            }
        }

        async function deleteCollection(collectionId) {
            if (!confirm('Are you sure you want to delete this collection?')) return;

            try {
                const res = await fetch(`${API_BASE}/collections/${collectionId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (res.ok) {
                    document.getElementById('viewCollectionModal').classList.remove('active');
                    loadCollections();
                } else {
                    alert('Failed to delete collection');
                }
            } catch (err) {
                console.error(err);
                alert('Failed to delete collection');
            }
        }

        async function createCollection(e) {
            e.preventDefault();

            const name = document.getElementById('collectionName').value.trim();
            const isSmart = document.getElementById('isSmartCollection').checked;
            const ruleLogic = document.getElementById('ruleLogic').value;

            const rules = [];
            if (isSmart) {
                document.querySelectorAll('#rulesList .rule-row').forEach(row => {
                    const field = row.querySelector('.rule-field').value;
                    const operator = row.querySelector('.rule-operator').value;
                    const value = row.querySelector('.rule-value').value.trim();
                    if (value) {
                        rules.push({ field, operator, value });
                    }
                });
            }

            try {
                const res = await fetch(`${API_BASE}/collections`, {
                    method: 'POST',
                    headers: { ...getAuthHeaders(), 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name,
                        is_smart: isSmart,
                        rule_logic: ruleLogic,
                        rules
                    })
                });

                if (res.ok) {
                    document.getElementById('newCollectionModal').classList.remove('active');
                    document.getElementById('newCollectionForm').reset();
                    document.getElementById('smartCollectionRules').style.display = 'none';
                    document.getElementById('collectionsModal').classList.add('active');
                    loadCollections();
                } else {
                    alert('Failed to create collection');
                }
            } catch (err) {
                console.error(err);
                alert('Failed to create collection');
            }
        }

        function addRuleRow() {
            const rulesList = document.getElementById('rulesList');
            const newRow = document.createElement('div');
            newRow.className = 'rule-row';
            newRow.style = 'display: flex; gap: 10px; margin-bottom: 10px;';
            newRow.innerHTML = `
                <select class="rule-field" style="flex: 1;">
                    <option value="author">Author</option>
                    <option value="title">Title</option>
                    <option value="series">Series</option>
                    <option value="format">Format</option>
                    <option value="content_type">Type (Book/Comic)</option>
                    <option value="year">Year</option>
                    <option value="rating">Rating</option>
                    <option value="read_status">Read Status</option>
                    <option value="tags">Tag</option>
                </select>
                <select class="rule-operator" style="flex: 1;">
                    <option value="contains">Contains</option>
                    <option value="equals">Equals</option>
                    <option value="starts_with">Starts With</option>
                    <option value="greater_than">Greater Than</option>
                    <option value="less_than">Less Than</option>
                </select>
                <input type="text" class="rule-value" style="flex: 1;" placeholder="Value">
                <button type="button" class="remove-rule-btn" style="padding: 5px 10px;">X</button>
            `;
            rulesList.appendChild(newRow);

            newRow.querySelector('.remove-rule-btn').addEventListener('click', () => {
                newRow.remove();
            });
        }

        // Collections Event Listeners
        document.getElementById('collectionsBtn').addEventListener('click', () => {
            document.getElementById('collectionsModal').classList.add('active');
            loadCollections();
        });

        document.getElementById('closeCollectionsBtn').addEventListener('click', () => {
            document.getElementById('collectionsModal').classList.remove('active');
        });

        document.getElementById('collectionsModal').addEventListener('click', (e) => {
            if (e.target.id === 'collectionsModal') {
                document.getElementById('collectionsModal').classList.remove('active');
            }
        });

        document.getElementById('newCollectionBtn').addEventListener('click', () => {
            document.getElementById('collectionsModal').classList.remove('active');
            document.getElementById('newCollectionModal').classList.add('active');
        });

        document.getElementById('cancelNewCollectionBtn').addEventListener('click', () => {
            document.getElementById('newCollectionModal').classList.remove('active');
            document.getElementById('collectionsModal').classList.add('active');
        });

        document.getElementById('newCollectionModal').addEventListener('click', (e) => {
            if (e.target.id === 'newCollectionModal') {
                document.getElementById('newCollectionModal').classList.remove('active');
            }
        });

        document.getElementById('isSmartCollection').addEventListener('change', (e) => {
            document.getElementById('smartCollectionRules').style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('addRuleBtn').addEventListener('click', addRuleRow);

        document.getElementById('newCollectionForm').addEventListener('submit', createCollection);

        // Remove rule button handler for initial rule
        document.querySelector('#rulesList .remove-rule-btn').addEventListener('click', function() {
            if (document.querySelectorAll('#rulesList .rule-row').length > 1) {
                this.closest('.rule-row').remove();
            }
        });

        document.getElementById('closeViewCollectionBtn').addEventListener('click', () => {
            document.getElementById('viewCollectionModal').classList.remove('active');
        });

        document.getElementById('viewCollectionModal').addEventListener('click', (e) => {
            if (e.target.id === 'viewCollectionModal') {
                document.getElementById('viewCollectionModal').classList.remove('active');
            }
        });

        document.getElementById('deleteCollectionBtn').addEventListener('click', () => {
            if (currentViewingCollectionId) {
                deleteCollection(currentViewingCollectionId);
            }
        });

        // Statistics functionality
        async function loadStatistics() {
            try {
                // Load summary stats
                const summaryRes = await fetch(`${API_BASE}/stats/summary`, { headers: getAuthHeaders() });
                if (summaryRes.ok) {
                    const summary = await summaryRes.json();
                    document.getElementById('statBooksRead').textContent = summary.books_completed || 0;
                    document.getElementById('statPagesRead').textContent = summary.pages_read || 0;
                    document.getElementById('statTotalTime').textContent = summary.total_time_formatted || '0m';
                    document.getElementById('statCurrentStreak').textContent = summary.current_streak || 0;
                    document.getElementById('statLongestStreak').textContent = summary.longest_streak || 0;
                }

                // Load daily stats for chart
                const dailyRes = await fetch(`${API_BASE}/stats/daily?days=30`, { headers: getAuthHeaders() });
                if (dailyRes.ok) {
                    const dailyStats = await dailyRes.json();
                    renderDailyChart(dailyStats);
                }

                // Load recent sessions
                const sessionsRes = await fetch(`${API_BASE}/stats/sessions?limit=10`, { headers: getAuthHeaders() });
                if (sessionsRes.ok) {
                    const sessions = await sessionsRes.json();
                    renderRecentSessions(sessions);
                }
            } catch (err) {
                console.error('Failed to load statistics:', err);
            }
        }

        function renderDailyChart(dailyStats) {
            const container = document.getElementById('dailyChart');
            if (!dailyStats || dailyStats.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted);">No reading data yet. Start reading to see your stats!</div>';
                return;
            }

            // Find max for scaling
            const maxTime = Math.max(...dailyStats.map(d => d.time_seconds), 1);

            container.innerHTML = dailyStats.map(day => {
                const height = Math.max((day.time_seconds / maxTime) * 150, day.time_seconds > 0 ? 5 : 2);
                const minutes = Math.round(day.time_seconds / 60);
                const date = new Date(day.date);
                const dayLabel = date.getDate();
                const hasData = day.time_seconds > 0;

                return `
                    <div style="display: flex; flex-direction: column; align-items: center; min-width: 18px;" title="${day.date}: ${minutes}min">
                        <div style="height: ${height}px; width: 14px; background: ${hasData ? 'var(--accent-color)' : 'var(--border-color)'}; border-radius: 3px; transition: height 0.3s;"></div>
                        <div style="font-size: 9px; color: var(--text-muted); margin-top: 4px;">${dayLabel}</div>
                    </div>
                `;
            }).join('');
        }

        function renderRecentSessions(sessions) {
            const container = document.getElementById('recentSessions');
            if (!sessions || sessions.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 20px;">No reading sessions yet.</div>';
                return;
            }

            container.innerHTML = sessions.map(session => {
                const startTime = new Date(session.start_time);
                const dateStr = startTime.toLocaleDateString();
                const timeStr = startTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const duration = Math.round(session.duration_seconds / 60);

                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color);">
                        <div>
                            <div style="font-weight: 500;">${session.book_title || 'Unknown Book'}</div>
                            <div style="font-size: 12px; color: var(--text-muted);">${session.book_author || ''}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 500;">${duration}min</div>
                            <div style="font-size: 11px; color: var(--text-muted);">${dateStr} ${timeStr}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Stats button event listener
        document.getElementById('statsBtn').addEventListener('click', () => {
            document.getElementById('statsModal').classList.add('active');
            loadStatistics();
        });

        document.getElementById('closeStatsBtn').addEventListener('click', () => {
            document.getElementById('statsModal').classList.remove('active');
        });

        document.getElementById('statsModal').addEventListener('click', (e) => {
            if (e.target.id === 'statsModal') {
                document.getElementById('statsModal').classList.remove('active');
            }
        });

        // Upload Modal Event Listeners
        document.getElementById('uploadBtn').addEventListener('click', () => {
            document.getElementById('uploadModal').classList.add('active');
        });

        document.getElementById('cancelBtn').addEventListener('click', closeUploadModal);

        document.getElementById('uploadModal').addEventListener('click', (e) => {
            if (e.target.id === 'uploadModal') closeUploadModal();
        });

        document.getElementById('dropZone').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleBatchUpload(e.target.files);
            }
        });

        document.getElementById('dropZone').addEventListener('dragover', (e) => {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        });

        document.getElementById('dropZone').addEventListener('dragleave', (e) => {
            e.currentTarget.classList.remove('dragover');
        });

        document.getElementById('dropZone').addEventListener('drop', (e) => {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                handleBatchUpload(e.dataTransfer.files);
            }
        });

        // Clear upload button - reset modal for new uploads
        document.getElementById('clearUploadBtn').addEventListener('click', () => {
            resetUploadModal();
        });

        // Retry failed uploads
        document.getElementById('retryFailedBtn').addEventListener('click', () => {
            const failedFiles = batchUploadState.results
                .filter(r => r.status === 'failed')
                .map(r => batchUploadState.files.find(f => f.name === r.file))
                .filter(f => f);
            if (failedFiles.length > 0) {
                handleBatchUpload(failedFiles);
            }
        });

        document.getElementById('sortSelect').addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'author') {
                groupBy = 'author';
                loadGrouped('author');
            } else if (val === 'series') {
                groupBy = 'series';
                loadGrouped('series');
            } else {
                groupBy = null;
                loadBooks();
            }
        });

        document.getElementById('typeSelect').addEventListener('change', () => {
            groupBy = null;
            localStorage.setItem('webby-content-type', document.getElementById('typeSelect').value);
            loadBooks();
        });

        document.getElementById('statusSelect').addEventListener('change', () => {
            groupBy = null;
            localStorage.setItem('webby-read-status', document.getElementById('statusSelect').value);
            loadBooks();
        });

        document.getElementById('tagSelect').addEventListener('change', () => {
            groupBy = null;
            loadBooks();
        });

        document.getElementById('searchBox').addEventListener('input', debounce(() => {
            groupBy = null;
            loadBooks();
        }, 300));

        document.getElementById('gridViewBtn').addEventListener('click', () => {
            viewMode = 'grid';
            document.getElementById('gridViewBtn').classList.add('active');
            document.getElementById('listViewBtn').classList.remove('active');
            if (groupBy) loadGrouped(groupBy);
            else renderBooks();
        });

        document.getElementById('listViewBtn').addEventListener('click', () => {
            viewMode = 'list';
            document.getElementById('listViewBtn').classList.add('active');
            document.getElementById('gridViewBtn').classList.remove('active');
            if (groupBy) loadGrouped(groupBy);
            else renderBooks();
        });

        // Series Grouping Toggle
        document.getElementById('groupOffBtn').addEventListener('click', () => {
            groupSeries = false;
            expandedSeries = null;
            document.getElementById('groupOffBtn').classList.add('active');
            document.getElementById('groupSeriesBtn').classList.remove('active');
            localStorage.setItem('webby-group-series', 'false');
            renderBooks();
        });

        document.getElementById('groupSeriesBtn').addEventListener('click', () => {
            groupSeries = true;
            document.getElementById('groupSeriesBtn').classList.add('active');
            document.getElementById('groupOffBtn').classList.remove('active');
            localStorage.setItem('webby-group-series', 'true');
            renderBooks();
        });

        function debounce(fn, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // Group books by series for collapsed view
        function groupBooksBySeries(bookList) {
            const seriesGroups = {};
            const standalone = [];

            bookList.forEach(book => {
                if (book.series && book.series.trim()) {
                    const seriesName = book.series.trim();
                    if (!seriesGroups[seriesName]) {
                        seriesGroups[seriesName] = [];
                    }
                    seriesGroups[seriesName].push(book);
                } else {
                    standalone.push(book);
                }
            });

            // Sort books within each series by series_index
            Object.keys(seriesGroups).forEach(seriesName => {
                seriesGroups[seriesName].sort((a, b) => (a.series_index || 0) - (b.series_index || 0));
            });

            return { seriesGroups, standalone };
        }

        // Render a series card (stacked cover visual)
        function renderSeriesCard(seriesName, seriesBooks) {
            const firstBook = seriesBooks[0];
            const coverUrl = `${API_BASE}/books/${firstBook.id}/cover`;
            const escapedTitle = firstBook.title.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const bookCount = seriesBooks.length;
            const author = firstBook.author || 'Unknown Author';

            return `
                <div class="book-card series-card" data-series-name="${seriesName}" onclick="toggleSeriesExpand('${seriesName.replace(/'/g, "\\'")}')">
                    <div class="series-cover-stack">
                        <img src="${coverUrl}" alt="${seriesName}" onerror="this.outerHTML='<div class=\\'series-placeholder\\'>${escapedTitle}</div>'">
                    </div>
                    <div class="series-info">
                        <div class="series-title">${seriesName}</div>
                        <span class="series-count">${bookCount} book${bookCount > 1 ? 's' : ''}</span>
                        <div class="series-author">${author}</div>
                    </div>
                </div>
            `;
        }

        // Render expanded series view
        function renderExpandedSeries(seriesName, seriesBooks) {
            return `
                <div class="series-expanded" data-expanded-series="${seriesName}">
                    <div class="series-expanded-header">
                        <span class="series-expanded-title">${seriesName} (${seriesBooks.length} books)</span>
                        <button class="series-collapse-btn" onclick="collapseSeriesView(event)">Collapse</button>
                    </div>
                    <div class="series-books-grid">
                        ${seriesBooks.map(renderBook).join('')}
                    </div>
                </div>
            `;
        }

        // Toggle series expansion
        function toggleSeriesExpand(seriesName) {
            if (expandedSeries === seriesName) {
                expandedSeries = null;
            } else {
                expandedSeries = seriesName;
            }
            renderBooks();
        }

        // Collapse expanded series view
        function collapseSeriesView(event) {
            event.stopPropagation();
            expandedSeries = null;
            renderBooks();
        }

        // ==================== MOBILE UI FUNCTIONS ====================

        // Filter Drawer
        function openFilterDrawer() {
            document.getElementById('filterDrawer').classList.add('active');
            document.getElementById('filterOverlay').classList.add('active');
            document.body.style.overflow = 'hidden';
            syncDrawerWithMainFilters();
        }

        function closeFilterDrawer() {
            document.getElementById('filterDrawer').classList.remove('active');
            document.getElementById('filterOverlay').classList.remove('active');
            document.body.style.overflow = '';
        }

        function syncDrawerWithMainFilters() {
            // Sync drawer inputs with main controls
            document.getElementById('drawerSearchInput').value = document.getElementById('searchBox').value;
            document.getElementById('drawerTypeSelect').value = document.getElementById('typeSelect').value;
            document.getElementById('drawerStatusSelect').value = document.getElementById('statusSelect').value;
            document.getElementById('drawerTagSelect').innerHTML = document.getElementById('tagSelect').innerHTML;
            document.getElementById('drawerTagSelect').value = document.getElementById('tagSelect').value;
            document.getElementById('drawerSortSelect').value = document.getElementById('sortSelect').value;

            // View toggle
            const isGrid = document.getElementById('gridViewBtn').classList.contains('active');
            document.getElementById('drawerGridBtn').classList.toggle('active', isGrid);
            document.getElementById('drawerListBtn').classList.toggle('active', !isGrid);

            // Group toggle
            const isGroupOff = document.getElementById('groupOffBtn').classList.contains('active');
            document.getElementById('drawerGroupOffBtn').classList.toggle('active', isGroupOff);
            document.getElementById('drawerGroupSeriesBtn').classList.toggle('active', !isGroupOff);
        }

        function syncMainWithDrawerFilters() {
            // Sync main controls with drawer
            document.getElementById('searchBox').value = document.getElementById('drawerSearchInput').value;
            document.getElementById('typeSelect').value = document.getElementById('drawerTypeSelect').value;
            document.getElementById('statusSelect').value = document.getElementById('drawerStatusSelect').value;
            document.getElementById('tagSelect').value = document.getElementById('drawerTagSelect').value;
            document.getElementById('sortSelect').value = document.getElementById('drawerSortSelect').value;
        }

        // Mobile Search
        function openMobileSearch() {
            document.getElementById('mobileSearchContainer').classList.add('active');
            document.getElementById('mobileSearchInput').focus();
        }

        function closeMobileSearch() {
            document.getElementById('mobileSearchContainer').classList.remove('active');
        }

        // Header hide on scroll
        let lastScrollY = 0;
        let headerHidden = false;
        function handleHeaderScroll() {
            const currentScrollY = window.scrollY;
            const header = document.getElementById('mainHeader');

            if (currentScrollY > lastScrollY && currentScrollY > 100 && !headerHidden) {
                header.classList.add('hidden');
                headerHidden = true;
            } else if (currentScrollY < lastScrollY && headerHidden) {
                header.classList.remove('hidden');
                headerHidden = false;
            }
            lastScrollY = currentScrollY;
        }

        // Swipe gesture handling
        function setupSwipeGestures() {
            // Filter drawer swipe to close
            const drawer = document.getElementById('filterDrawer');
            const overlay = document.getElementById('filterOverlay');
            let touchStartX = 0;
            let touchStartY = 0;
            let touchMoveX = 0;
            let drawerTranslate = 0;
            let isDragging = false;

            drawer.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isDragging = false;
                drawerTranslate = 0;
                drawer.style.transition = 'none';
            }, { passive: true });

            drawer.addEventListener('touchmove', (e) => {
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const diffX = touchStartX - touchX;
                const diffY = Math.abs(touchStartY - e.touches[0].clientY);

                // Only handle horizontal swipes (swipe left to close)
                if (diffX > 10 && diffY < 50) {
                    isDragging = true;
                    drawerTranslate = Math.min(0, -diffX);
                    drawer.style.transform = `translateX(${drawerTranslate}px)`;
                    overlay.style.opacity = Math.max(0, 1 + (drawerTranslate / 280));
                }
            }, { passive: true });

            drawer.addEventListener('touchend', () => {
                drawer.style.transition = 'transform 0.3s ease';
                if (isDragging && drawerTranslate < -80) {
                    closeFilterDrawer();
                } else {
                    drawer.style.transform = '';
                    overlay.style.opacity = '';
                }
                isDragging = false;
            });

            // Modal swipe-to-dismiss (swipe down)
            document.querySelectorAll('.modal').forEach(modal => {
                const content = modal.querySelector('.modal-content');
                if (!content) return;

                let modalTouchStartY = 0;
                let modalTranslateY = 0;
                let modalIsDragging = false;

                content.addEventListener('touchstart', (e) => {
                    // Only allow drag from top area of modal
                    const rect = content.getBoundingClientRect();
                    if (e.touches[0].clientY - rect.top > 60) return;

                    modalTouchStartY = e.touches[0].clientY;
                    modalIsDragging = false;
                    modalTranslateY = 0;
                    content.style.transition = 'none';
                }, { passive: true });

                content.addEventListener('touchmove', (e) => {
                    if (modalTouchStartY === 0) return;

                    const touchY = e.touches[0].clientY;
                    const diffY = touchY - modalTouchStartY;

                    // Only allow downward swipe
                    if (diffY > 10) {
                        modalIsDragging = true;
                        modalTranslateY = diffY;
                        content.style.transform = `translateY(${modalTranslateY}px)`;
                        modal.style.background = `rgba(0,0,0,${Math.max(0, 0.6 - (diffY / 500))})`;
                    }
                }, { passive: true });

                content.addEventListener('touchend', () => {
                    content.style.transition = 'transform 0.3s ease';
                    if (modalIsDragging && modalTranslateY > 100) {
                        modal.classList.remove('active');
                    }
                    content.style.transform = '';
                    modal.style.background = '';
                    modalTouchStartY = 0;
                    modalIsDragging = false;
                });
            });

            // Book card swipe actions
            setupBookCardSwipe();
        }

        function setupBookCardSwipe() {
            let swipeTarget = null;
            let swipeStartX = 0;
            let swipeStartY = 0;
            let swipeOffsetX = 0;
            let isSwipe = false;

            document.addEventListener('touchstart', (e) => {
                const card = e.target.closest('.book-card');
                if (!card || window.innerWidth > 768) return;

                swipeTarget = card;
                swipeStartX = e.touches[0].clientX;
                swipeStartY = e.touches[0].clientY;
                swipeOffsetX = 0;
                isSwipe = false;
                card.style.transition = 'none';
            }, { passive: true });

            document.addEventListener('touchmove', (e) => {
                if (!swipeTarget) return;

                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const diffX = touchX - swipeStartX;
                const diffY = Math.abs(touchY - swipeStartY);

                // Horizontal swipe detection
                if (Math.abs(diffX) > 15 && diffY < 30) {
                    isSwipe = true;
                    swipeOffsetX = diffX;
                    // Limit swipe distance
                    const maxSwipe = 80;
                    const limitedX = Math.max(-maxSwipe, Math.min(maxSwipe, diffX));
                    swipeTarget.style.transform = `translateX(${limitedX}px)`;

                    // Show action hints with visual feedback
                    swipeTarget.classList.remove('swiping-right', 'swiping-left');
                    if (diffX > 40) {
                        swipeTarget.style.background = 'linear-gradient(90deg, rgba(46, 204, 113, 0.2) 0%, transparent 50%)';
                        swipeTarget.classList.add('swiping-right');
                    } else if (diffX < -40) {
                        swipeTarget.style.background = 'linear-gradient(270deg, rgba(231, 76, 60, 0.2) 0%, transparent 50%)';
                        swipeTarget.classList.add('swiping-left');
                    } else {
                        swipeTarget.style.background = '';
                    }
                }
            }, { passive: true });

            document.addEventListener('touchend', () => {
                if (!swipeTarget) return;

                swipeTarget.style.transition = 'transform 0.3s ease, background 0.3s ease';

                if (isSwipe) {
                    const bookId = swipeTarget.dataset.id;
                    if (swipeOffsetX > 60) {
                        // Swipe right - toggle reading list (want to read)
                        quickToggleReadingList(bookId, 'want_to_read');
                    } else if (swipeOffsetX < -60) {
                        // Swipe left - show quick actions
                        showMobileActionMenu(bookId);
                    }
                }

                swipeTarget.style.transform = '';
                swipeTarget.style.background = '';
                swipeTarget.classList.remove('swiping-right', 'swiping-left');
                swipeTarget = null;
                isSwipe = false;
            });
        }

        function showMobileActionMenu(bookId) {
            const book = books.find(b => b.id === bookId);
            if (!book) return;

            // Set book data for action handlers
            mobileActionBookId = bookId;
            mobileActionBookData = book;

            const menu = document.getElementById('mobileActionMenu');
            document.getElementById('mobileActionTitle').textContent = book.title;
            document.getElementById('mobileActionAuthor').textContent = `by ${book.author || 'Unknown'}`;

            menu.classList.add('active');

            // Close on backdrop click
            menu.onclick = (e) => {
                if (e.target === menu) {
                    closeMobileActionMenu();
                }
            };
        }

        // Setup mobile UI event listeners
        function setupMobileUI() {
            // Menu button
            document.getElementById('menuBtn').addEventListener('click', openFilterDrawer);
            document.getElementById('filterOverlay').addEventListener('click', closeFilterDrawer);
            document.getElementById('closeDrawerBtn').addEventListener('click', closeFilterDrawer);

            // Mobile search
            document.getElementById('searchToggleBtn').addEventListener('click', openMobileSearch);
            document.getElementById('closeSearchBtn').addEventListener('click', closeMobileSearch);
            document.getElementById('mobileSearchInput').addEventListener('input', (e) => {
                document.getElementById('searchBox').value = e.target.value;
                filterBooks();
            });

            // FAB
            document.getElementById('fabUpload').addEventListener('click', () => {
                document.getElementById('uploadModal').classList.add('active');
            });

            // Bottom navigation
            document.getElementById('navLibrary').addEventListener('click', () => {
                setActiveNav('navLibrary');
                closeFilterDrawer();
            });
            document.getElementById('navCollections').addEventListener('click', () => {
                setActiveNav('navCollections');
                document.getElementById('collectionsModal').classList.add('active');
            });
            document.getElementById('navStats').addEventListener('click', () => {
                setActiveNav('navStats');
                loadStats();
                document.getElementById('statsModal').classList.add('active');
            });
            document.getElementById('navMore').addEventListener('click', () => {
                openFilterDrawer();
            });

            // Drawer filter sync
            ['drawerSearchInput', 'drawerTypeSelect', 'drawerStatusSelect', 'drawerTagSelect', 'drawerSortSelect'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    syncMainWithDrawerFilters();
                    filterBooks();
                });
            });
            document.getElementById('drawerSearchInput').addEventListener('input', () => {
                syncMainWithDrawerFilters();
                filterBooks();
            });

            // Drawer view toggles
            document.getElementById('drawerGridBtn').addEventListener('click', () => {
                document.getElementById('drawerGridBtn').classList.add('active');
                document.getElementById('drawerListBtn').classList.remove('active');
                document.getElementById('gridViewBtn').click();
            });
            document.getElementById('drawerListBtn').addEventListener('click', () => {
                document.getElementById('drawerListBtn').classList.add('active');
                document.getElementById('drawerGridBtn').classList.remove('active');
                document.getElementById('listViewBtn').click();
            });

            // Drawer group toggles
            document.getElementById('drawerGroupOffBtn').addEventListener('click', () => {
                document.getElementById('drawerGroupOffBtn').classList.add('active');
                document.getElementById('drawerGroupSeriesBtn').classList.remove('active');
                document.getElementById('groupOffBtn').click();
            });
            document.getElementById('drawerGroupSeriesBtn').addEventListener('click', () => {
                document.getElementById('drawerGroupSeriesBtn').classList.add('active');
                document.getElementById('drawerGroupOffBtn').classList.remove('active');
                document.getElementById('groupSeriesBtn').click();
            });

            // Header hide on scroll (mobile only)
            if (window.innerWidth < 768) {
                window.addEventListener('scroll', handleHeaderScroll, { passive: true });
            }

            // Update drawer user info
            updateDrawerUserInfo();

            // Setup swipe gestures for mobile
            if (window.innerWidth < 768) {
                setupSwipeGestures();
            }
        }

        function setActiveNav(activeId) {
            document.querySelectorAll('.bottom-nav-item').forEach(item => {
                item.classList.toggle('active', item.id === activeId);
            });
        }

        function updateDrawerUserInfo() {
            const userInfo = document.getElementById('drawerUserInfo');
            if (currentUser) {
                const initial = currentUser.username.charAt(0).toUpperCase();
                userInfo.innerHTML = `
                    <div class="user-avatar">${initial}</div>
                    <div>
                        <div style="font-weight: 600;">${currentUser.username}</div>
                        <div style="font-size: 12px; color: var(--text-secondary);">${currentUser.email || ''}</div>
                    </div>
                `;
            }
        }

        // Mobile Action Menu Functions
        function openMobileActionMenu(bookId) {
            const book = books.find(b => b.id === bookId);
            if (!book) return;

            mobileActionBookId = bookId;
            mobileActionBookData = book;

            document.getElementById('mobileActionTitle').textContent = book.title;
            document.getElementById('mobileActionAuthor').textContent = `by ${book.author}`;
            document.getElementById('mobileActionMenu').classList.add('active');
        }

        function closeMobileActionMenu() {
            document.getElementById('mobileActionMenu').classList.remove('active');
            mobileActionBookId = null;
            mobileActionBookData = null;
        }

        async function mobileActionRead() {
            if (mobileActionBookId) {
                openReader(mobileActionBookId);
            }
            closeMobileActionMenu();
        }

        async function mobileActionViewDetails() {
            if (mobileActionBookId) {
                openBookDetail(mobileActionBookId);
            }
            closeMobileActionMenu();
        }

        async function mobileActionEdit() {
            if (mobileActionBookId) {
                // Load book data first, then open edit modal
                currentBookId = mobileActionBookId;
                try {
                    const res = await fetch(`${API_BASE}/books/${mobileActionBookId}`, { headers: getAuthHeaders() });
                    if (res.ok) {
                        currentBookData = await res.json();
                        closeMobileActionMenu();
                        openEditModal();
                    }
                } catch (err) {
                    console.error(err);
                }
            }
        }

        async function mobileActionRefresh() {
            if (mobileActionBookId) {
                currentBookId = mobileActionBookId;
                closeMobileActionMenu();
                // Open detail modal and trigger refresh
                await openBookDetail(mobileActionBookId);
                refreshMetadata();
            }
        }

        async function mobileActionSearch() {
            if (mobileActionBookId) {
                currentBookId = mobileActionBookId;
                try {
                    const res = await fetch(`${API_BASE}/books/${mobileActionBookId}`, { headers: getAuthHeaders() });
                    if (res.ok) {
                        currentBookData = await res.json();
                        closeMobileActionMenu();
                        openSearchModal();
                    }
                } catch (err) {
                    console.error(err);
                }
            }
        }

        async function mobileActionDelete() {
            if (!mobileActionBookId || !mobileActionBookData) return;

            if (confirm(`Are you sure you want to delete "${mobileActionBookData.title}"?`)) {
                try {
                    const res = await fetch(`${API_BASE}/books/${mobileActionBookId}`, {
                        method: 'DELETE',
                        headers: getAuthHeaders()
                    });
                    if (res.ok) {
                        closeMobileActionMenu();
                        loadBooks();
                    } else {
                        alert('Failed to delete book');
                    }
                } catch (err) {
                    alert('Failed to delete book');
                }
            }
            closeMobileActionMenu();
        }

        // Close mobile menu when clicking backdrop
        document.getElementById('mobileActionMenu').addEventListener('click', (e) => {
            if (e.target.id === 'mobileActionMenu') {
                closeMobileActionMenu();
            }
        });

        // Long-press and right-click handler setup
        function setupBookCardInteractions() {
            // Use event delegation on the library container
            const library = document.getElementById('library');

            // Touch events for long-press (mobile)
            library.addEventListener('touchstart', (e) => {
                const bookCard = e.target.closest('.book-card');
                if (!bookCard) return;

                const bookId = bookCard.dataset.bookId;
                if (!bookId) return;

                bookCard.classList.add('pressing');

                longPressTimer = setTimeout(() => {
                    bookCard.classList.remove('pressing');
                    longPressTriggered = true;
                    openMobileActionMenu(bookId);
                }, LONG_PRESS_DURATION);
            }, { passive: false });

            library.addEventListener('touchend', (e) => {
                const bookCard = e.target.closest('.book-card');
                if (bookCard) {
                    bookCard.classList.remove('pressing');
                }
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            library.addEventListener('touchmove', (e) => {
                const bookCard = e.target.closest('.book-card');
                if (bookCard) {
                    bookCard.classList.remove('pressing');
                }
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });

            // Right-click for desktop context menu
            library.addEventListener('contextmenu', (e) => {
                const bookCard = e.target.closest('.book-card');
                if (!bookCard) return;

                const bookId = bookCard.dataset.bookId;
                if (!bookId) return;

                e.preventDefault();
                openMobileActionMenu(bookId);
            });
        }

        // Load saved grouping preference
        function loadGroupingPreference() {
            const saved = localStorage.getItem('webby-group-series');
            if (saved === 'true') {
                groupSeries = true;
                document.getElementById('groupSeriesBtn').classList.add('active');
                document.getElementById('groupOffBtn').classList.remove('active');
            }
        }

        // Load saved content type filter preference
        function loadContentTypePreference() {
            const saved = localStorage.getItem('webby-content-type');
            if (saved !== null) {
                document.getElementById('typeSelect').value = saved;
            }
        }

        // Load saved read status filter preference
        function loadStatusPreference() {
            const saved = localStorage.getItem('webby-read-status');
            if (saved !== null) {
                document.getElementById('statusSelect').value = saved;
            }
        }

        // Initialize
        async function init() {
            const isLoggedIn = await checkAuth();
            if (isLoggedIn) {
                loadGroupingPreference();
                loadContentTypePreference();
                loadStatusPreference();
                loadBooks();
                setupBookCardInteractions();
                setupMobileUI();
                // Pre-load reading lists for authenticated users
                loadReadingLists();
                // Pre-load user tags
                loadUserTags();
                // Initialize star rating interactions
                initStarRating();
            }
        }
        init();
    </script>
</body>
</html>
